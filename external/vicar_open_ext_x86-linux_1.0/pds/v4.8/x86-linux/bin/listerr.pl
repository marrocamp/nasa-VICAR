#!/usr/bin/perl
#
# Script: listerr.pl - List ODL validation errors on a volume
# Usage:  listerr.pl [-f] <lvtool report>
#
# Author: Joel Wilf
# Date: 6/30/99
#
# Description:
#   This script scans the output of lvtool and lists all the errors.
#   If the -f option is set, the output is sorted by file.  Otherwise, 
#   it is sorted by error type.
#
#   Note: Prior to running listerr.pl, lvtool must be run with the
#   -nw option set.
# End:
#
# Revisions:
#   1999-08-18, J. Wilf, Removed extension filtering (it's done by lvtool)
#   1999-08-19, J. Wilf, Added sorting by error
#   2003-04-03, M. Cayanan, Added capability to find and print out warning 
#		and informational messages too.
#   2003-09-16, M. Cayanan, Added capability to allow user to choose and select
#               which messages to see what files they occurred in. The default
#               now is to just show in the report a summary of the messages that
#               were generated during the label validation testing. This summary
#               consists of how many files and how much they occurred. 
#   2003-09-17, M. Cayanan, Added capability to capture the header information in
#               the lvtool report. This will allow the output of this script to display
#               what settings were set when the test was run.
#   2004-11-21, M. Cayanan, Changed the way this script captures the file name from
#               the lvtool report. 
# End:

use Tk;

use Getopt::Long;
Getopt::Long::Configure("bundling");
$| = 1;

# Process command line
#getopts('fe');     # If -f is set, $opt_f == 1
GetOptions("s" => \$opt_s,
           "em=s" => \$opt_em,
           "help" => \$opt_help
          );
$usage = "listerr.pl <lvtool report> --em <filename> -s --help";

if($opt_help)
{
	print "\n\nPROGRAM USAGE: $usage\n\nwhere,\n";
	print "      <lvtool report>\tAn lvtool report file. This input is required by\n"; 
	print "                     \tlisterr.pl\n";
	print "      --em <filename>\tSpecify the file that includes a list of messages\n";
	print "                     \tto exclude from the label validation report. This \n";
	print "                     \tfile is generated by using \"tkvalid.pl --lvt\"\n";
	print "       -s            \tDisplay the window containing a summary of\n";
	print "                     \tmessages found in the label validation report.\n";
	print "                     \tDefault is to not show this window.\n";
	exit;
}

$counter = 1;

# 04-10-03 MDC
# Get the exclude file if '-e' was specified.
if($opt_em) {
   $exclude_file = shift or die "Can't find file: $opt_em";
   
   #Copy the messages onto an array
   open(EXCLUDE, "<$exclude_file") or die "Can't open file: $opt_em";
   
   while($line = <EXCLUDE>) {
      chop ($line);
      push @msgs_to_ignore, $line;
   }
   
   close EXCLUDE;
   
   foreach $exclude_msg (@msgs_to_ignore) {
   	
      $exclude_msg =~ s/(%d)/(\.*)/g;
      $exclude_msg =~ s/(%s)/(\.*)/g;
   }
}


$report = shift or die "USAGE: $usage\n"; 
die "Can\'t find $report\n" unless (-e $report);
die "Invalid $report\n" unless (-f $report);

# Scan for errors
print "\n\nFinding Label Validation Errors:\n";
print "================================================================\n";
open (REPORT,"<$report");
while ($line = <REPORT>) {
    
    # When expanding pointers, ODL syntax errors will appear twice in the lvtool report this script
    # is looking at. So, this is to eliminate redundancy.
    if ($line =~ m/(.+)Messages from LABEL file(.+)/) {
    	do {
    		$line = <REPORT>;
    	} until $line =~ m/(.+)End of messages for LABEL file(.+)/;
    }
    
    # When expanding pointers, ODL syntax messages may appear for the files the label is pointing to.
    # This piece of code will be able to recognize this and grab the filename that the messages are
    # referring to.
    if ($line =~ m/(.+)ODL syntax messages for STRUCTURE file:(.+)/) {
    	$file_name = $2;
    	$file_name =~ s|\*||g;      # Get rid of '*' in the string
    	$file_name =~ s/^\s+//;     # Get rid of leading whitespaces
    	$file_name =~ s/\s+$//;     # Get rid of trailing whitespaces
    	$file_name =~ s|\w:||g;     # Get rid of the volume letter
    	$file_name =~ s/\\/\//g;    # Switch all the '\' to '/' for Windows
    	$file_name =~ s|^/||;       # Get rid of the leading '/'
    }
    
    #Get Label Validation Test Options that were set and put it in the final report
    if ($line =~ m/(.+)Data Dictionary Validation(.+)/) {
    	
    	print "\nThe following options were set during the Label Validation Test:\n";
    	
    	do {
    		$line =~ s|\*||g;     # Get rid of '*' in the string
    		$line =~ s/^\s+//;    # Get rid of leading whitespaces
    		$line =~ s/\s+$//;    # Get rid of trailing whitespaces
    		print "\t $line\n";
    		$line = <REPORT>;
    	} until $line =~ m/\*{72}/;   # Stop when you've reached the end of the header in the report
    	
    	print "\n\n\n\n";
    }
    
    # Get filename
    if (substr($line,0,1) eq '#') {
 #   	$line =~ m/(\w\S+)\s/;  # Extract file name from line.
        # 11-21-04 MDC - New way to parse the file name from the line
        # This says "match a string that may or may not have spaces
        # in between and that ends with a 3 character extension." This
        # fixes the cases where a directory path involves spaces
        # i.e. C:\Documents and Settings\...
 	$line =~ m/(\w+.*\.\S{3})\s/;
 	$file_name = $1;
        $file_name =~ s|\w:||g; # On Windows, get rid of volume letter.
	$file_name =~ s/\\/\//g; # Replace all '\' with '/'
        $file_name =~ s|^/||;   # Get rid of leading /.
    }
    
    # Filter out results from bad file types
    if (scalar @extlist != 0) {
    	$bad_file_flag = 0;
    	$bad_file_flag = 1 if ($file_name !~ m/\./);
    	foreach $extension (@extlist) {
    	    $bad_file_flag = 1 if ($file_name =~ m/\.$extension/i);
    	}
    	next if ($bad_file_flag == 1);
    }
        
    # Get syntactic errors 
     if ($line =~ m/ERROR:   (.+)/) {
     	$error = $1;
     	@split_error = split ' -- ', $error;
     	$error_type = $split_error[1];
     	
     	# 04-07-03 MDC - This is used in case an ERROR message is found that 
        # does not contain a line number such as a duplicate GROUP names ERROR
        # message. 
        if($split_error[1] eq "") {
             $error_type = $split_error[0];
        }
    	
    	# Check to see if the error message is part of our list
    	# we want to ignore
    	$found = check_msg($error_type);
    	
    	if($found == 0) {
    	    
    	   # This chunk of code captures the block at the beginning of the lvtool report that lists all the 
    	   # names of files that are not in the PDS-Standard required uppercase format.
    	   if($error_type =~ m/(.+)following files will be excluded from processing because PDS standards require/) {
    	   	# Read all filenames until a blank line is found
    	   	while(($line = <REPORT>) && ($line !~ m/^\s*$/)) {
    	   		chop($line);
    	   		$line =~ s|\w:||g; # On Windows, get rid of volume letter.
			$line =~ s/\\/\//g; # Replace all '\' with '/'
        		$line =~ s|^/||;   # Get rid of leading /.
    	   		push @syn_errs, "$line:  $error";
    	   		push @error_types, $error_type;
    	   	}
    	   }
    	   else {
    	   	push @syn_errs, "$file_name: $error";
    	   	push @error_types, $error_type;
    	   }
    	}
    }
    
    # Get unfound pointer errors
        if ($line =~ m/Error File not found: (\w.+)/) {
    	$error = $1;
    	push @pnt_errs, "  $file_name --> $error";
    }
    
    # 04-02-03 MDC - Get Informational messages
    if ($line =~ m/INFO:    (.+)/) {
    	$info = $1;
    	@split_info = split ' -- ', $info;
    	$info_type = $split_info[1];
    	push @syn_info, "$file_name: $info";
    	push @info_types, $info_type;
    }
    
    # 04-02-03 MDC - Get Warning messages
    if ($line =~ m/WARNING: (.+)/) {
    	$warning = $1;
    	if($warning !~ /Label reading complete/) {
    	    @split_warning = split ' -- ', $warning;
    	    $warning_type = $split_warning[1];
    
            # 04-16-03 MDC - This is used in case a WARNING message is found that 
            # does not contain a line number.
             
            if($split_warning[1] eq "") {
                $warning_type = $split_warning[0];
            }
    	    
    	    #Check to see if the message type is on our 
    	    #list to ignore
    	    $found = check_msg($warning_type);
    	    
    	    if($found == 0) {
    	       push @syn_warning, "$file_name: $warning";
    	       push @warning_types, $warning_type;
    	    }
        }
    }
}
close REPORT;

# Sort all arrays
@syn_errs = sort @syn_errs;
@error_types = sort @error_types;
@pnt_errs = sort @pnt_errs;

@syn_info = sort @syn_info;
@info_types = sort @info_types;
@syn_warning = sort @syn_warning;
@warning_types = sort @warning_types;

# Make an array of the unique syn errs
$prev_type = "";
while ($type = shift @syn_errs) {
	push @unique_syn_errs, $type if ($type ne $prev_type);
    	$prev_type = $type;
}

# Default sort is by error type
unless ($opt_f == 1) {
	
    # Make an array of the unique error types
    $prev_type = "";
    while ($type = shift @error_types) {
    	push @unique_error_types, $type if ($type ne $prev_type);
        $prev_type = $type;
    }
    
    # Find all files that contain each error type
    foreach $unique_type (@unique_error_types) {
    	$file_count = 0;
    	
    	#Empty out array
    	@unique_filenames = ();
    	
    	$occurrences = 0;
    	
	push @sorted_errors, $unique_type;
        foreach $err (@unique_syn_errs) {
            @split_err = split ' -- ', $err;
            $err_type = $split_err[1];   
            
            if($split_err[1] eq "") {
    	       @split_err = split /:\s+/, $err;
    	       $err_type = $split_err[1];
    	    }
        	
            if ($err_type eq $unique_type) {
                $file_and_line = "\t" . $split_err[0];
                push @sorted_errors, $file_and_line;
                #If the file has already been saved, then
                #don't count it.
                if(find_dup_filename($file_and_line) == 0) {
                	++$file_count;
                }
                ++$occurrences;
            }
        }
        
        # Tally the number of occurrences and the number of files this 
        # unique error has been found in
        if($occurrences == 1) {
    		$note = "1 occurrence";
    	}
    	else {
    		$note = "$occurrences occurrences";
    	}
        if($file_count == 1) {
        	$note = "$note in $file_count " . "file -- " . "$unique_type";
        }
        else {
        	$note = "$note in $file_count " . "files -- " . "$unique_type";
        }
        push @summary_err_list, $note;
    }
    
    #04-02-03 MDC - Do the same for info and warning messages
    $prev_type = "";
    while ($type = shift @warning_types) {
    	push @unique_warning_types, $type if ($type ne $prev_type);
    	$prev_type = $type;
    }
    
    foreach $unique_type (@unique_warning_types) {
        push @sorted_warnings, $unique_type;
        $file_count = 0;
        $occurrences = 0;
        #Empty out array
    	@unique_filenames = ();
    	
    	foreach $warn (@syn_warning) {
    	    @split_warn = split ' -- ', $warn;
    	    $warn_type = $split_warn[1];
    	    
    	    if($split_warn[1] eq "") {
    	       @split_warn = split /:\s+/, $warn;
    	       $warn_type = $split_warn[1];
    	    }
    	    if ($warn_type eq $unique_type) {
    	    	$file_and_line = "\t" . $split_warn[0];
    	    	push @sorted_warnings, $file_and_line;
    	    	if(find_dup_filename($file_and_line) == 0) {
                	++$file_count;
                }
                ++$occurrences;
    	    }
    	}
    	
    	if($occurrences == 1) {
    		$note = "1 occurrence";
    	}
    	else {
    		$note = "$occurrences occurrences";
    	}
    	
    	if($file_count == 1) {
        	$note = "$note in $file_count " . "file -- " . "$unique_type";
        }
        else {
        	$note = "$note in $file_count " . "files -- " . "$unique_type";
        }
        push @summary_warn_list, $note;
    }
    
    $prev_type = "";
    while ($type = shift @info_types) {
    	push @unique_info_types, $type if ($type ne $prev_type);
    	$prev_type = $type;
    }
    
    foreach $unique_type (@unique_info_types) {
       push @sorted_info, $unique_type;
       $file_count = 0;
       $occurrences = 0;
       
       #Empty out array
       @unique_filenames = ();
       
       foreach $inf (@syn_info) {
       	   @split_inf = split ' -- ', $inf;
       	   $inf_type = $split_inf[1];
       	   if ($inf_type eq $unique_type) {
       	   	$file_and_line = "\t" . $split_inf[0];
       	   	push @sorted_info, $file_and_line;
       	       	if(find_dup_filename($file_and_line) == 0) {
                	++$file_count;
                }
                ++$occurrences;	
       	   }
       }
       if($occurrences == 1) {
       		$note = "1 occurrence";
       }
       else {
    		$note = "$occurrences occurrences";
       }
       if($file_count == 1) {
        	$note = "$note in $file_count " . "file -- " . "$unique_type";
       }
       else {
        	$note = "$note in $file_count " . "files -- " . "$unique_type";
       }
       push @summary_info_list, $note;
    }
}

if($opt_s)
{
	create_summary_window();
}
else
{
	$show_filenames_for_all = 1;
}

### Display results

prepare_report();



sub check_msg
{
   my $msg = shift(@_);
   
   foreach $exclude_msg (@msgs_to_ignore) {
      if($msg =~ /(.*)$exclude_msg(\w)*/) {
         return 1;
      }
   }

   return 0;
   
}

#################################################
# This subroutine will check to see if a unique #
# filename is already stored in the array.      #
#################################################
sub find_dup_filename
{
	my $file = shift(@_);
	
	my @file_info = split ':', $file;
	my $fname = $file_info[0];  
	
	#If the array is empty, add the filename onto the
	#array.
	if(@unique_filenames + 0 == 0) {
		push @unique_filenames, $fname;
		return 0;
	}
	else {
		foreach $unique_name (@unique_filenames) {
			if($fname eq $unique_name) {
				return 1;
			} 
		}
		# Couldn't find the file, add it to the list
		push @unique_filenames, $fname;
		return 0;
	}
}


#########################################################
# This routine will create a GUI that will allow a user #
# to select which messages they would like to see get   #
# printed that also shows the filenames that it         #
# occurred in. Otherwise, just a summary of the number  #
# of files and how many times it occurred will be       #
# printed out in the report                             #
#########################################################
sub create_summary_window {
	
	$err_sum = 0;
	$warn_sum = 0;
	$info_sum = 0;

	
$title_text = <<"EOF1";
Below is a summary of the messages generated during the validation test. Each message contains the number of files that particular 
message was found in and the number of times it occurred throughout the test. Selecting messages from this screen will allow the 
final report to contain associated filenames for each selection that was made. A brief summary of each non-selected message will
also be in the report.

Select the messages that you would like to see what files they occurred in. Click on the radio buttons (Error Messages, Info Messages, 
Warning Messages) to browse through the different types of messages. When you are finished, click "Continue". If you would like to 
see all associated filenames for each of the messages, click "Show Filenames for all messages".
EOF1
		
	$mw = MainWindow->new();
	
	# Exit program if user closes GUI window
	$mw->protocol( WM_DELETE_WINDOW, sub {exit;} );
	
	# Frame 1 is the title of the GUI
	
	$f1 = $mw->title("Summary of Errors Found");
	
	$f1 = $mw->Frame->pack(-anchor => 'nw', -fill => 'x');
	
	$f1->Label(
               -font => "Times 11 normal",
               -text => "$title_text",
               -relief => 'groove',
               -justify => 'left',
              )->pack(
                      -anchor => 'nw',
                      -expand => 1,
                      -fill => 'x',
                      -pady => 15
                     );
	
	# Frame 2 is the buttons that will continue or cancel the processing
	
	$f2 = $mw->Frame->pack(-side => 'top', -fill => 'x'); 



	$f2->Button(-text => 'Show Filenames For All Messages',
			-font => 'Times 11 bold',
			-command =>  sub {$show_filenames_for_all = 1; execute();}
			)->pack(
				-side => 'left',
				-expand => 1,
				-fill => 'x',
				-padx => 10,
				-pady => 15
				);
	
	$f2->Button(-text => "Continue",
		   -command => \&execute,
		   -font => 'Times 11 bold'
		  )->pack(
		  	  -side => 'left',
		  	  -expand => 1,
		  	  -fill => 'x',
		  	  -padx => 10,
		  	  -pady => 15
		  	 );
	
	$f2->Button(-font => "Times 11 bold",
		   -text => "Exit",
		   -command => sub {exit}
		  )->pack(
		  	  -side => 'left',
		  	  -expand => 1,
		  	  -fill => 'x',
		  	  -padx => 10,
		  	  -pady => 15
		  	 );
	
	
	# Frame 3 consists of the messages that the user will be able to choose from
	
	$f3 = $mw->Frame->pack(-side => 'top', -fill => 'x');
	
	$rb_err = $f3->Radiobutton(-text => 'Error Messages',
			-variable => \$show_msgs,
		#	-relief => 'ridge',
			-value => 'error',
			-command => \&setup_msgs
			)->pack(
				-side => 'left',
				-expand => 1,
				-fill => 'x',
				-pady => 5
				);
	
	$rb_warn = $f3->Radiobutton(-text => 'Warning Messages',
			-variable => \$show_msgs,
		#	-relief => 'ridge',
			-value => 'warn',
			-command => \&setup_msgs
			)->pack(
				-side => 'left',
				-expand => 1,
				-fill => 'x',
				-pady => 5
				);

	$rb_inf = $f3->Radiobutton(-text => 'Informational Messages',
			-variable => \$show_msgs,
		#	-relief => 'ridge',
			-value => 'info',
			-command => \&setup_msgs
			)->pack(
				-side => 'left',
				-expand => 1,
				-fill => 'x',
				-pady => 5
				);
	
	$yscroll = $mw->Scrollbar();
	$xscroll = $mw->Scrollbar(-orient => 'horizontal');
	
	$lb = $mw->Listbox(-yscrollcommand => ['set' => $yscroll],
			   -xscrollcommand => ['set' => $xscroll],
			   -width => 75,
			   -height => 15,
			   -selectmode => 'extended',
			   -background => 'white'
			   );
	$yscroll->configure(-command => ['yview' => $lb]);
	$xscroll->configure(-command => ['xview' => $lb]);
	$yscroll->pack(-side => 'left', -fill => 'y');
	$xscroll->pack(-side => 'bottom', -fill => 'x');
	$lb->pack(-side => 'left',
		  -fill => 'both',
		  -expand => 1
		  );
		  
	$rb_err->invoke();

	MainLoop;
}	

####################################################
# Routine that is called when user hits "continue" #
# on the summary of messages window                #
####################################################
sub execute
{
	setup_msgs();
	create_new_msg_sets();
	
	$mw->destroy();
	$mw = "";
	
	return;
}

###########################################################
# This routine will save, retrieve, and show the user the #
# different types of messages that were found during the  #
# label validation test                                   #
###########################################################
sub setup_msgs {
	
	#Save the selections before clearing out the list
	if( ($prev_sel eq 'error') && ($no_err_msgs != 1) ) {
		@selected_err_list = $lb->curselection();
	}
	if ( ($prev_sel eq 'warn') && ($no_warn_msgs != 1) ) {
		@selected_warn_list = $lb->curselection();
	}
	if ( ($prev_sel eq 'info') && ($no_info_msgs != 1) ) {
		@selected_info_list = $lb->curselection();
	}
	
	$lb->delete(0, 'end');
	
	if($show_msgs eq 'error') {
		
		if(scalar (@summary_err_list) == 0) {
			$lb->insert('end', "No Error Messages");
			$no_err_msgs = 1;
		}
		else {
			$lb->insert('end', @summary_err_list);
		}
		
		#Retrieve what the user has selected
		foreach $index (@selected_err_list) {
			$lb->selectionSet($index);
		}
		$prev_sel = 'error';

	}
	if($show_msgs eq 'warn') {
		
		if(scalar (@summary_warn_list) == 0) {
			$lb->insert('end', "No Warning Messages");
			$no_warn_msgs = 1;
		}
		else {
			$lb->insert('end', @summary_warn_list);
		}
		
		foreach $index (@selected_warn_list) {
			$lb->selectionSet($index);
		}
		$prev_sel = 'warn';
	}
	if($show_msgs eq 'info') {
		
		if(scalar (@summary_info_list) == 0) {
			$lb->insert('end', "No Informational Messages");
			$no_info_msgs = 1;
		}
		else {
			$lb->insert('end', @summary_info_list);
		}
		
		foreach $index (@selected_info_list) {
			$lb->selectionSet($index);
		}
		$prev_sel = 'info';
	}
}

############################################################
# This routine will filter out and separate those messages # 
# where the user wants to see the filenames as well and    #
# those messages that will just be used in the summary     #
# portion of the report                                    #
############################################################
sub create_new_msg_sets
{
	
	# These will contain the errors and filenames of those messages that the user has selected
	@rev_messages = (
			 [ @rev_sorted_errors ],
			 [ @rev_sorted_warns ],
			 [ @rev_sorted_info ],
			 );
	
	#This contains the original list of sorted messages before the user was prompted to select
	@orig_messages = (
			 [ @sorted_errors ],
			 [ @sorted_warnings ],
			 [ @sorted_info ],
			 );
	
	#This contains the messages that show on the screen where it specifies the amount of occurrences
	#and the number of files an error was found in
	@summary_messages = (
			    [ @summary_err_list ],
			    [ @summary_warn_list ],
			    [ @summary_info_list ],
			    );
			    
	#This contains the indices of what the user selected to see which filenames a particular error was
	#found in 
	@user_selected_messages = (
				  [ @selected_err_list ],
				  [ @selected_warn_list ],
				  [ @selected_info_list ],
				  );
	
	#This will contain just a list of those messages that the user did not select. This will be used
	#for the summary portion of the report
	@output_sum_msgs = (
			   [ @output_err_msgs ],
			   [ @output_warn_msgs ],
			   [ @output_info_msgs ],
			   );
	
	for($array_index = 0; $array_index < 3; $array_index++) {
	
		$index_orig_list = 0;
		$index_user_selection = 0;
	
		for($index_sum_list = 0; $index_sum_list < scalar(@{$summary_messages[$array_index]}); ++$index_sum_list) {
		
			# Split the string that contains the number of occurrences and the error type
			@split_msg = split ' -- ', $summary_messages[$array_index][$index_sum_list];
		
			# What we want now is the number of occurrences the message was found in. Split the
			# string and this number should be found in the first element of the array.
			@freq = split /\s+/, $split_msg[0];
		
			#If this message is one that the user has selected....
			if( ($index_sum_list == $user_selected_messages[$array_index][$index_user_selection]) &&
			    (scalar(@{$user_selected_messages[$array_index]}) != 0) ) {
				
				#Save it onto the array
				push @{$rev_messages[$array_index]}, $orig_messages[$array_index][$index_orig_list++];
				
				#Record also the filenames that error was found in
				for($counter = 0; $counter < $freq[0]; $counter++) {
					push @{$rev_messages[$array_index]}, $orig_messages[$array_index][$index_orig_list++];
				}
				#Increment to the next selection the user selected
				++$index_user_selection; 
			}
			#If the user chose not to see which filenames the message was found in...
			else {
				#Record the message onto the array
				push @{$output_sum_msgs[$array_index]}, $orig_messages[$array_index][$index_orig_list++];
				#Also record the number of files it was found in and how many times it occurred
				push @{$output_sum_msgs[$array_index]}, "\t$split_msg[0]";
				
				#Update the counter to point to the next message type in the original array list
				for($counter = 0; $counter < $freq[0]; $counter++) {
					$index_orig_list++;
				}
			}
		}		
	}
}

sub prepare_report()
{
		# Display Syntax Errors - by error type (default)
	unless ($opt_f == 1) {
	
	    # If user selected a mix of messages they did and did not want to see...
	    if($show_filenames_for_all == 0){
	    	
		$index = 0;
		@rev_sorted_errors = @{$rev_messages[$index]};
		@output_err_msgs = @{$output_sum_msgs[$index]};
		
		print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
		print ">>                                  <<\n";
		print ">>          ERROR MESSAGES          <<\n";
		print ">>                                  <<\n";
	    	print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\n";   	
	    	if (scalar @rev_sorted_errors > 0) {
	    		print "------------------------------------------------------------------------------\n";
	    		print "** Below is a list of the selected error messages with associated filenames **\n";
	    		print "------------------------------------------------------------------------------\n";
	    		
	    		# We want to number each error type that we print in the report. Since the error types do
	    		# not contain a tab character at the beginning of the string, we can check for this. Tab 
	    		# characters are found in the "file and line" error messages in the array.
	    		for($i = 0, $counter = 1; $i < scalar(@rev_sorted_errors); $i++)
	    		{
	    			if($rev_sorted_errors[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $rev_sorted_errors[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $rev_sorted_errors[$i]);
	    			}
	    		}
	    	}
	    	
	    	
	    	if (scalar @output_err_msgs > 0) {
	    		print"\n\n\n";
	    		if(scalar @rev_sorted_errors == 0) {
	    			print "----------------------------------------------\n";
	    			print "** Below is a summary of the error messages **\n";
	    			print "----------------------------------------------\n";
	    		}
	    		else {
	    			print "--------------------------------------------------------\n";
	    			print "** Below is a summary of the remaining error messages **\n";
	    			print "--------------------------------------------------------\n";
	    		}
	    		
	    		for($i = 0, $counter = 1; $i < scalar(@output_err_msgs); $i++)
	    		{
	    			if($output_err_msgs[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $output_err_msgs[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $output_err_msgs[$i]);
	    			}
	    		}
	    	}
	    	
	    	if( (scalar @rev_sorted_errors == 0) && (scalar @output_err_msgs == 0) ) {
	    		print "There are no ODL syntax errors.\n";
	    	}
	    	print "\n\n\n\n";
	    	
	    	++$index;
	       	@rev_sorted_warns = @{$rev_messages[$index]};
	    	@output_warn_msgs = @{$output_sum_msgs[$index]};
	
	    	
	    	print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
	    	print ">>                                  <<\n";
	    	print ">>         WARNING MESSAGES         <<\n";
	    	print ">>                                  <<\n";
	    	print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n\n";
	    	if (scalar @rev_sorted_warns > 0) {
	    		print "--------------------------------------------------------------------------------\n";
	    		print "** Below is a list of the selected warning messages with associated filenames **\n";
	    		print "--------------------------------------------------------------------------------\n";
	    		
	    		for($i = 0, $counter = 1; $i < scalar(@rev_sorted_warns); $i++)
	    		{
	    			if($rev_sorted_warns[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $rev_sorted_warns[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $rev_sorted_warns[$i]);
	    			}
	    		}
	    	}
	    	
	    	if (scalar @output_warn_msgs > 0) {
	    		print "\n\n\n";
	    		if(scalar @rev_sorted_warns == 0) {
	    			print "------------------------------------------------\n";
	    			print "** Below is a summary of the warning messages **\n";
	    			print "------------------------------------------------\n";
	    		}
	    		else {
	    			print "----------------------------------------------------------\n";
	    			print "** Below is a summary of the remaining warning messages **\n";
	    			print "----------------------------------------------------------\n";
	    		}
	    		
	    		for($i = 0, $counter = 1; $i < scalar(@output_warn_msgs); $i++)
	    		{
	    			if($output_warn_msgs[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $output_warn_msgs[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $output_warn_msgs[$i]);
	    			}
	    		}
	    	}
	    	
	    	if( (scalar @rev_sorted_warns == 0) && (scalar @output_warn_msgs == 0) ) {
	    		print "\nThere are no warning messages.";
	    	}
	    	print "\n\n\n\n";
	    	
	    	++$index;
	    	@rev_sorted_info = @{$rev_messages[$index]};
	    	@output_info_msgs = @{$output_sum_msgs[$index]};
	    	
	    	print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
	    	print ">>                                  <<\n";
	    	print ">>     INFORMATIONAL MESSAGES       <<\n";
	    	print ">>                                  <<\n";
	    	print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\n";
	    	
	    	if (scalar @rev_sorted_info > 0) {
	    		print "-----------------------------------------------------------------------------\n";
	    		print "** Below is a list of the selected info messages with associated filenames **\n";
	    		print "-----------------------------------------------------------------------------\n";
	    		
	    		for($i = 0, $counter = 1; $i < scalar(@rev_sorted_info); $i++)
	    		{
	    			if($rev_sorted_info[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $rev_sorted_info[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $rev_sorted_info[$i]);
	    			}
	    		}
	    	}
	    	    	
	    	if (scalar @output_info_msgs > 0) {
	    		print "\n\n\n";
	    		if(scalar @rev_sorted_info == 0) {
	    			print "---------------------------------------------\n";
	    			print "** Below is a summary of the info messages **\n";
	    			print "---------------------------------------------\n";
	    		}
	    		else {
	    			print "-------------------------------------------------------\n";
	    			print "** Below is a summary of the remaining info messages **\n";
	    			print "-------------------------------------------------------\n";
	    		}
	    		
	    		for($i = 0, $counter = 1; $i < scalar(@output_info_msgs); $i++)
	    		{
	    			if($output_info_msgs[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $output_info_msgs[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $output_info_msgs[$i]);
	    			}
	    		}
	    	}
	    	
	    	if( (scalar @rev_sorted_info == 0) && (scalar @output_info_msgs == 0) ) {
	    		print "\nThere are no info messages.";
	    	}
	    	print "\n\n\n";
	    }
	    else {  # If the user decided to show all associated filenames for each message type.
	    	if (scalar @sorted_errors > 0) {
	 		print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
	 		print ">>                                  <<\n";    	
	    		print ">>         ERROR MESSAGES           <<\n";
	    		print ">>                                  <<\n";
	    		print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n"; 
		        
		        for($i = 0, $counter = 1; $i < scalar(@sorted_errors); $i++)
	    		{
	    			if($sorted_errors[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $sorted_errors[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $sorted_errors[$i]);
	    			}
	    		}
	    		
	    	} else {
	        	print "\nThere are no ODL syntax errors.\n";
	    	}
	    	print "\n\n\n\n";
	    	
	    	#Display Warnings and Info messages
	    
	    	if (scalar @sorted_warnings > 0) {
	    		print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
	    		print ">>                                  <<\n";
	    		print ">>        WARNING MESSAGES          <<\n";
	    		print ">>                                  <<\n";
	    		print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n";
	  		
	  		for($i = 0, $counter = 1; $i < scalar(@sorted_warnings); $i++)
	    		{
	    			if($sorted_warnings[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $sorted_warnings[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $sorted_warnings[$i]);
	    			}
	    		}
	    	} else {
	    		print "\nThere are no warning messages.\n";
	    	}
	    	print "\n\n\n\n";
	    
	    	if (scalar @sorted_info > 0) {
	    		print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
	    		print ">>                                   <<\n";
	    		print ">>     INFORMATIONAL MESSAGES        <<\n";
	    		print ">>                                   <<\n";
	    		print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n";
	    		
	    		for($i = 0, $counter = 1; $i < scalar(@sorted_info); $i++)
	    		{
	    			if($sorted_info[$i] !~ m/^\t/)
	    			{
	    				printf("\n\n(#$counter) %s", $sorted_info[$i]);    		
	    				$counter++;
	    			}
	    			else
	    			{
	    				printf("\n%s", $sorted_info[$i]);
	    			}
	    		}
	    	} else {
	    		print "\nThere are no info messages.\n";
	    	}
	    	print "\n\n\n";
	   }
	}
	
	
	# MDC - For now, this option is disabled
	
	# Display Syntax Errors - by file (-f option)
	if ($opt_f == 1) {
	    if (scalar @unique_syn_errs > 0) {
	        print "Syntax Errors:\n\n";
	        $prev_entry = "";
	        while ($entry = shift @unique_syn_errs) {
	            print "$entry\n" unless ($entry eq $prev_entry);
	            $prev_entry = $entry;
	        }
	    } else {
	        print "There are no ODL syntax errors\n";
	    }
	    print "\n\n";
	    
	    #04-02-03 MDC - Display info and warning messages too
	    
	    if (scalar @syn_warning > 0) {
	    	print "Warning messages:\n\n";
	    	$prev_entry = "";
	    	while ($entry = shift @syn_warning) {
	            print "$entry\n" unless ($entry eq $prev_entry);
	            $prev_entry = $entry;
	        }
	    } else {
	    	print "There are no warning messages\n";
	    }
	    print "\n\n";
	    
	    if (scalar @sys_info > 0) {
	    	print "Info messages:\n\n";
	    	$prev_entry = "";
	    	while ($entry = shift @syn_info) {
	    	    print "$entry\n" unless ($entry eq $prev_entry);
	    	    $prev_entry = $entry;
	    	}
	    } else {
	    	print "There are no info messages\n";
	    }
	    print "\n\n\n";
	}
	
	# Display Pointer Errors
	$counter = 1;
	@pnt_errs = sort @pnt_errs;
	if (scalar @pnt_errs > 0) {
	    print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
	    print ">>                                                                   <<\n";
	    print ">>    POINTER ERRORS (file --> object pointed to but not found)      <<\n";
	    print ">>                                                                   <<\n";
	    print "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
	    print "\n\n";
	    
	    $prev_entry = "";
	    while ($entry = shift @pnt_errs) {
	        print "(#$counter) $entry\n\n" unless ($entry eq $prev_entry);
	        $counter++;
	        $prev_entry = $entry;
	    }
	} else {
	    print "There are no pointer errors.\n";
	}
	print "\n\n";
}