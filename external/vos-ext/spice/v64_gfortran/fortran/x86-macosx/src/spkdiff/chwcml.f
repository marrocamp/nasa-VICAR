C$Procedure      CHWCML ( Extract arguments from SPKDIFF command line )
  
      SUBROUTINE CHWCML ( LINE, SPK, BODNAM, BODID, CENNAM, CENID, 
     .                    FRAME, TIME, ET, NITR, STEP, DIFTYP, TIMFMT,
     .                    KERNLS )


C$ Abstract
C
C     Extract arguments from SPKDIFF command line and return them
C     and or default values via individual variables. If input command
C     line is incomplete or if specific command line keys requesting
C     help are specified, this routine displays usage and stops the 
C     program.
C
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Required_Reading
C
C     SPKDIFF User's Guide.
C
C$ Keywords
C
C     TBD.
C
C$ Declarations
  
      IMPLICIT NONE
 
      INCLUDE              'spkdiff.inc'

      CHARACTER*(*)         LINE
      CHARACTER*(*)         SPK    ( 2 )
      CHARACTER*(*)         BODNAM ( 2 )
      INTEGER               BODID  ( 2 )
      CHARACTER*(*)         CENNAM ( 2 )
      INTEGER               CENID  ( 2 )
      CHARACTER*(*)         FRAME  ( 2 )
      CHARACTER*(*)         TIME   ( 2 )
      DOUBLE PRECISION      ET     ( 2 )
      INTEGER               NITR
      DOUBLE PRECISION      STEP
      CHARACTER*(*)         DIFTYP
      CHARACTER*(*)         TIMFMT
      CHARACTER*(*)         KERNLS
  
C$ Brief_I/O
C
C     Variable  I/O  Description
C     --------  ---  --------------------------------------------------
C     LINE       I   SPKDIFF command line
C     SPK        O   1st and 2nd SPK file names
C     BODNAM     O   1st and 2nd body names
C     BODID      O   1st and 2nd body IDs
C     CENNAM     O   1st and 2nd center names
C     CENID      O   1st and 2nd center IDs
C     FRAME      O   1st and 2nd frame names
C     TIME       O   Start and stop time as strings
C     ET         O   Start and stop time as ET seconds
C     NITR       O   Number of points to be used in comparison.
C     STEP       O   Time step in seconds.
C     DIFTYP     O   Type of summary to be generated by SPKDIFF.
C     TIMFMT     O   Output time format string "dump" summaries.
C     KERNLS     O   List of additional kernels.
C
C$ Detailed_Input
C
C     LINE        is the command line provided to SPKDIFF. See SPKDIFF
C                 User's Guide for the command line syntax and detailed
C                 specification of allowed arguments.
C
C$ Detailed_Output
C
C     SPK         is a two element array containing the names of the
C                 first and second SPK files.
C
C     BODNAM      is a two element array containing the names of the
C                 first and second bodies, position of which is to be
C                 computed.
C
C     BODID       is a two element array containing the ID of the first
C                 and second bodies, position of which is to be
C                 computed.
C     
C     CENNAM      is a two element array containing the names of the
C                 first and second bodies, position with respect to
C                 which is to be computed.
C     
C     CENID       is a two element array containing the IDs of the first
C                 and second bodies, position with respect to which is
C                 to be computed.
C     
C     FRAME       is a two element array containing the names of the
C                 first and second frames, in which position is to be
C                 computed.
C     
C     TIME        is a two element array containing the start and stop
C                 times of the comparison interval presented as
C                 strings.
C     
C     ET          is a two element array containing the start and stop
C                 times of the comparison interval presented as
C                 ET seconds past J2000.
C     
C     NITR        is the number of points to be used in comparison.
C
C     STEP        is the time step in seconds.
C
C     DIFTYP      is a string indicating the type of summary to be
C                 generated by SPKDIFF.
C
C     TIMFMT      is a string containing output time format picture for
C                 "dump"-type summaries.
C
C     KERNLS      is a string containing the list of additional kernels
C                 provided on the command line.
C
C$ Parameters
C
C     See include file.
C
C$ Exceptions
C
C     TBD.
C
C$ Files
C
C     TBD.
C
C$ Particulars
C
C     TBD.
C
C$ Examples
C
C     TBD.
C
C$ Restrictions
C
C     TBD.
C
C$ Literature_References
C
C     TBD.
C
C$ Author_and_Institution
C
C     B.V. Semenov   (JPL)
C
C$ Version
C
C-    Version 1.0.0, 18-APR-2006 (BVS).
C
C-&
 
C
C     SPICELIB functions
C
      DOUBLE PRECISION      DPMAX
      DOUBLE PRECISION      DPMIN

      INTEGER               CARDD
      INTEGER               ISRCHC
      INTEGER               RTRIM
      INTEGER               WDCNT
      INTEGER               INTMAX

      LOGICAL               EQSTR
      LOGICAL               EXISTS

C
C     Local variables.
C
      CHARACTER*(3)         ARCH
      CHARACTER*(3)         TYPE
      CHARACTER*(DSPSIZ)    USGMSG ( USGCNT )
      CHARACTER*(DSPSIZ)    VERMSG ( VERCNT )
      CHARACTER*(LINSIZ)    CLVALS ( MAXKEY )
      CHARACTER*(LINSIZ)    ERROR
      CHARACTER*(LINSIZ)    HLINE
      CHARACTER*(LINSIZ)    KERNAM
      CHARACTER*(WRDSIZ)    CLKEYS ( MAXKEY )
      CHARACTER*(WRDSIZ)    CLKEYU ( MAXKEY )
      CHARACTER*(WRDSIZ)    HWORD

      DOUBLE PRECISION      COVER1 ( LBCELL : WINSIZ )
      DOUBLE PRECISION      COVER2 ( LBCELL : WINSIZ )
      DOUBLE PRECISION      COVERC ( LBCELL : WINSIZ + 2 )
      DOUBLE PRECISION      DC     ( ND )
      DOUBLE PRECISION      DESCR  ( ND + NI/2 )
      DOUBLE PRECISION      HDP1
      DOUBLE PRECISION      HDP2      

      INTEGER               FRAMID
      INTEGER               HANDLE
      INTEGER               I
      INTEGER               IC     ( NI )
      INTEGER               ICLSTB ( NI )
      INTEGER               ICLSTN ( NI )
      INTEGER               ICLSTS ( NI )
      INTEGER               NARGS
      INTEGER               PTR

      LOGICAL               CLFLAG ( MAXKEY )
      LOGICAL               FOUND

C
C     Save everything to prevent potential memory problems in f2c'ed
C     version.
C
      SAVE

C
C     Initialize command line keys.
C
      DATA ( CLKEYS(I), I =  1, MAXKEY )
     .     /
     .      SB1KEY,
     .      SC1KEY,
     .      FR1KEY,
     .      SB2KEY,
     .      SC2KEY,
     .      FR2KEY,
     .      KERKEY,
     .      BEGKEY,
     .      ENDKEY,
     .      NSTKEY,
     .      STPKEY,
     .      FMTKEY,
     .      TYPKEY,
     .      USGKEY,
     .      UKEY,
     .      HLPKEY,
     .      HKEY
     .     /

C
C     Check in.
C
      CALL CHKIN ( 'CHWCML' )

C
C     Generate uppercase version of command lines keys.
C
      DO I = 1, MAXKEY
         CALL UCASE( CLKEYS(I), CLKEYU(I) )
      END DO

C
C     Initialize version display.
C
      CALL TKVRSN( 'TOOLKIT', HWORD )
      VERMSG(  1 ) = ' '
      VERMSG(  2 ) = PGMNAM // ' -- Version ' // PGMVER //
     .               ' -- Toolkit Version ' // HWORD(:RTRIM(HWORD))
      VERMSG(  3 ) = ' '
 
C
C     Initialize usage display.
C
      USGMSG(  1 ) = '   # computes differences between geometric ' 
     .//             'states obtained from '
      USGMSG(  2 ) = '   two SPK files and either displays these '
     .//             'differences or shows statistics '
      USGMSG(  3 ) = '   about them (see the User''s Guide for more '
     .//             'details.) The program usage is:'  
      USGMSG(  4 ) = ' '
      USGMSG(  5 ) = '      % # [options] <first SPK file> '
     .//             '<second SPK file>'
      USGMSG(  6 ) = ' '
      USGMSG(  7 ) = '   Options are shown below. Order and case '
     .//             'of keys are not significant.'
      USGMSG(  8 ) = '   Values must be space-separated from keys, '
     .//             'i.e. ''# 10'', not ''#10''.'
      USGMSG(  9 ) = ' '
      USGMSG( 10 ) = '      # <first body name or ID>'
      USGMSG( 11 ) = '      # <first center name or ID>'
      USGMSG( 12 ) = '      # <first reference frame name>'
      USGMSG( 13 ) = '      # <second body name or ID>'
      USGMSG( 14 ) = '      # <second center name or ID>'
      USGMSG( 15 ) = '      # <second reference frame name>'
      USGMSG( 16 ) = '      #  <other kernel file name(s)>'
      USGMSG( 17 ) = '      #  <interval start time>'
      USGMSG( 18 ) = '      #  <interval stop time>'
      USGMSG( 19 ) = '      #  <time step in seconds>'
      USGMSG( 20 ) = '      #  <number of states: # to # ('
     .//             'default: #)>'
      USGMSG( 21 ) = '      #  <output time format (default: '
     .//             'TDB seconds past J2000)>'
      USGMSG( 22 ) = '      #  <report type: #|#|#|# (default: '
     .//             '#)>'
      USGMSG( 23 ) = ' '
      CALL REPMC ( USGMSG(  1 ), '#', PGMNAM, USGMSG(  1 ) )
      CALL REPMC ( USGMSG(  5 ), '#', PGMNAM, USGMSG(  5 ) )
      CALL REPMC ( USGMSG(  8 ), '#', NSTKEY, USGMSG(  8 ) )
      CALL REPMC ( USGMSG(  8 ), '#', NSTKEY, USGMSG(  8 ) )
      CALL REPMC ( USGMSG( 10 ), '#', SB1KEY, USGMSG( 10 ) )
      CALL REPMC ( USGMSG( 11 ), '#', SC1KEY, USGMSG( 11 ) )
      CALL REPMC ( USGMSG( 12 ), '#', FR1KEY, USGMSG( 12 ) )
      CALL REPMC ( USGMSG( 13 ), '#', SB2KEY, USGMSG( 13 ) )
      CALL REPMC ( USGMSG( 14 ), '#', SC2KEY, USGMSG( 14 ) )
      CALL REPMC ( USGMSG( 15 ), '#', FR2KEY, USGMSG( 15 ) )
      CALL REPMC ( USGMSG( 16 ), '#', KERKEY, USGMSG( 16 ) )
      CALL REPMC ( USGMSG( 17 ), '#', BEGKEY, USGMSG( 17 ) )
      CALL REPMC ( USGMSG( 18 ), '#', ENDKEY, USGMSG( 18 ) )
      CALL REPMC ( USGMSG( 19 ), '#', STPKEY, USGMSG( 19 ) )
      CALL REPMC ( USGMSG( 20 ), '#', NSTKEY, USGMSG( 20 ) )
      CALL REPMI ( USGMSG( 20 ), '#', MINITR, USGMSG( 20 ) )
      CALL REPMI ( USGMSG( 20 ), '#', MAXITR, USGMSG( 20 ) )
      CALL REPMI ( USGMSG( 20 ), '#', DEFITR, USGMSG( 20 ) )
      CALL REPMC ( USGMSG( 21 ), '#', FMTKEY, USGMSG( 21 ) )
      CALL REPMC ( USGMSG( 22 ), '#', TYPKEY, USGMSG( 22 ) )
      CALL REPMC ( USGMSG( 22 ), '#', BSCVAL, USGMSG( 22 ) )
      CALL REPMC ( USGMSG( 22 ), '#', STSVAL, USGMSG( 22 ) )
      CALL REPMC ( USGMSG( 22 ), '#', DMPVAL, USGMSG( 22 ) )
      CALL REPMC ( USGMSG( 22 ), '#', DVFVAL, USGMSG( 22 ) )
      CALL REPMC ( USGMSG( 22 ), '#', BSCVAL, USGMSG( 22 ) )

C
C     Get command line and do first attempt at parsing. All we need to
C     find out in this try is if one of the help/usage key variations
C     was present.
C
      CALL GETCML ( LINE )
      HLINE = LINE
      CALL PARCML( HLINE, MAXKEY, CLKEYU, CLFLAG, CLVALS, FOUND )

C
C     Was command line blank? Is one of the usage or help keys
C     present? Display USAGE and STOP if yes.
C     
      NARGS = WDCNT( LINE )
      IF ( NARGS .LT. 2 .OR.
     .     CLFLAG( ISRCHC( HLPKEY, MAXKEY, CLKEYS ) ) .OR. 
     .     CLFLAG( ISRCHC( HKEY,   MAXKEY, CLKEYS ) ) .OR.
     .     CLFLAG( ISRCHC( USGKEY, MAXKEY, CLKEYS ) ) .OR. 
     .     CLFLAG( ISRCHC( UKEY,   MAXKEY, CLKEYS ) )       ) THEN
                
C
C        Display version.
C
         DO I = 1, VERCNT
            CALL TOSTDO( VERMSG(I) )
         END DO

C
C        Display usage and stop.
C
         DO I = 1, USGCNT
            CALL TOSTDO ( USGMSG(I) )
         END DO

         STOP

      END IF

C
C     Pull the last and second to last words from the command line.
C     These two words are supposed to be the names of the first and
C     second SPKs. Then parse what's left of the line again.
C
      CALL NTHWD ( LINE, NARGS,   SPK(2), PTR )
      CALL NTHWD ( LINE, NARGS-1, SPK(1), PTR )
      LINE(PTR:) = ' '

      HLINE = LINE
      CALL PARCML( HLINE, MAXKEY, CLKEYU, CLFLAG, CLVALS, FOUND )
      
C
C     Check if the first SPK exists and is an SPK.
C
      IF ( EXISTS( SPK(1) ) ) THEN

         CALL GETFAT ( SPK(1), ARCH, TYPE )

         IF ( .NOT. ( ARCH .EQ. 'DAF' .AND. TYPE .EQ. 'SPK' ) ) THEN
            CALL SETMSG ( 'File ''#'' specified as the second to '   //
     .                    'last argument on the command line is '    //
     .                    'not an SPK file.'                         )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL SIGERR ( 'SPICE(NOTANSPKFILE1)'                     )
         END IF

      ELSE
         CALL SETMSG ( 'File ''#'' specified as the second to last ' //
     .                 ' argument on the command line does not '     //
     .                 'exist.'                                      )
         CALL ERRCH  ( '#', SPK(1)                                   )
         CALL SIGERR ( 'SPICE(SPK1DOESNOTEXIST)'                     )
      END IF

C
C     Check if the second SPK exists and is an SPK.
C
      IF ( EXISTS( SPK(2) ) ) THEN

         CALL GETFAT ( SPK(2), ARCH, TYPE )

         IF ( .NOT. ( ARCH .EQ. 'DAF' .AND. TYPE .EQ. 'SPK' ) ) THEN
            CALL SETMSG ( 'File ''#'' specified as the last '        //
     .                    'argument on the command line is not '     //
     .                    'an SPK file.'                             )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL SIGERR ( 'SPICE(NOTANSPKFILE2)'                     )
         END IF
         
      ELSE
         CALL SETMSG ( 'File ''#'' specified as the last '           //
     .                 'argument on the command line does not '      //
     .                 'exist.'                                      )
         CALL ERRCH  ( '#', SPK(2)                                   )
         CALL SIGERR ( 'SPICE(SPK2DOESNOTEXIST)'                     )
      END IF

C
C     Go on processing the rest of the command line. All other
C     arguments are optional and, if not present, will have to be set
C     to some default values.
C

C
C     Were any other kernels provided on the command line? We need to
C     deal with kernels first because some of them may define frames 
C     and/or name-ID mappings that are needed to process the rest of 
C     command line arguments.
C
      I = ISRCHC( KERKEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         KERNLS = CLVALS(I)

         IF ( KERNLS .NE. ' ' ) THEN

C
C           Extract other kernels specified on the command line from
C           the list and load them one-by-one using FURNSH.
C            
            DO WHILE ( KERNLS .NE. ' ' )
               CALL NEXTWD( KERNLS, KERNAM, KERNLS )
               CALL FURNSH( KERNAM )
            END DO

C
C           Reset kernel list variable; this list will be included into
C           some of the reports generated by the program.
C
            KERNLS = CLVALS(I)

         ELSE
            CALL SETMSG ( 'Although ''#'' key was provided on the '  //
     .                    'command line no kernel file names were '  //
     .                    'following it.'                            )
            CALL ERRCH  ( '#', KERKEY                                )
            CALL SIGERR ( 'SPICE(MISSINGKERNELNAMES)'                )
         END IF

      ELSE
         
         KERNLS = ' '

      END IF

C
C     Was the center name or ID for the first SPK provided on the
C     command line?
C
      CENNAM(1) = ' '

      I = ISRCHC( SC1KEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         CENNAM(1) = CLVALS(I)
         CALL NPARSI ( CLVALS(I), CENID(1), ERROR, PTR )

         IF ( PTR .NE. 0 ) THEN
            
            CALL BODN2C ( CLVALS(I), CENID(1), FOUND )

            IF ( .NOT. FOUND ) THEN
               CALL SETMSG ( '''#'' specified after ''#'' key is '   //
     .                       'neither an integer number '            //
     .                       'representing a legitimate NAIF ID '    //
     .                       'nor an object name recognized in '     //
     .                       'SPICE.'                                )
               CALL ERRCH  ( '#', CLVALS(I)                          )
               CALL ERRCH  ( '#', SC1KEY                             )
               CALL SIGERR ( 'SPICE(BADCENTER1SPEC)'                 )
            END IF

         ELSE

            CALL BODC2N ( CENID(1), HWORD, FOUND )
            IF ( FOUND ) THEN
               CENNAM(1) = HWORD
            END IF

         END IF

      END IF

C
C     Was the body name or ID for the first SPK provided on the
C     command line?
C
      BODNAM(1) = ' '

      I = ISRCHC( SB1KEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         BODNAM(1) = CLVALS(I)
         CALL NPARSI ( CLVALS(I), BODID(1), ERROR, PTR )

         IF ( PTR .NE. 0 ) THEN

            CALL BODN2C ( CLVALS(I), BODID(1), FOUND )

            IF ( .NOT. FOUND ) THEN
               CALL SETMSG ( '''#'' specified after ''#'' key is '   //
     .                       'neither an integer number '            //
     .                       'representing a legitimate NAIF ID '    //
     .                       'nor an object name recognized in '     //
     .                       'SPICE.'                                )
               CALL ERRCH  ( '#', CLVALS(I)                          )
               CALL ERRCH  ( '#', SB1KEY                             )
               CALL SIGERR ( 'SPICE(BADBODY1SPEC)'                   )
            END IF

         ELSE

            CALL BODC2N ( BODID(1), HWORD, FOUND )
            IF ( FOUND ) THEN
               BODNAM(1) = HWORD
            END IF

         END IF

      END IF

C
C     Was the first frame name provided on the command line?
C
      FRAME(1) = ' '

      I = ISRCHC( FR1KEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         FRAME(1) = CLVALS(I)
         CALL NAMFRM( FRAME(1), FRAMID )

         IF ( FRAMID .EQ. 0 ) THEN
            CALL SETMSG ( 'Cannot recognize frame ''#'' provided '   //
     .                    'on the command line after ''#'' key.'     )
            CALL ERRCH  ( '#', FRAME(1)                              )
            CALL ERRCH  ( '#', FR1KEY                                )
            CALL SIGERR ( 'SPICE(BADFRAME1NAME)'                     )
         END IF

      END IF

C
C     Was the center name or ID for the second SPK provided on the
C     command line?
C
      CENNAM(2) = ' '

      I = ISRCHC( SC2KEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         CENNAM(2) = CLVALS(I)
         CALL NPARSI ( CLVALS(I), CENID(2), ERROR, PTR )

         IF ( PTR .NE. 0 ) THEN

            CALL BODN2C ( CLVALS(I), CENID(2), FOUND )

            IF ( .NOT. FOUND ) THEN
               CALL SETMSG ( '''#'' specified after ''#'' key is '   //
     .                       'neither an integer number '            //
     .                       'representing  a legitimate NAIF ID '   //
     .                       'nor an object name recognized in '     //
     .                       'SPICE.'                                )
               CALL ERRCH  ( '#', CLVALS(I)                          )
               CALL ERRCH  ( '#', SC2KEY                             )
               CALL SIGERR ( 'SPICE(BADCENTER2SPEC)'                 )
            END IF

         ELSE

            CALL BODC2N ( CENID(2), HWORD, FOUND )
            IF ( FOUND ) THEN
               CENNAM(2) = HWORD
            END IF

         END IF

      END IF
 
C
C     Was the body name or ID for the second SPK provided on the
C     command line?
C
      BODNAM(2) = ' '

      I = ISRCHC( SB2KEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         BODNAM(2) = CLVALS(I)
         CALL NPARSI ( CLVALS(I), BODID(2), ERROR, PTR )

         IF ( PTR .NE. 0 ) THEN

            CALL BODN2C ( CLVALS(I), BODID(2), FOUND )

            IF ( .NOT. FOUND ) THEN
               CALL SETMSG ( '''#'' specified after ''#'' key is '   //
     .                       'neither an integer number '            //
     .                       'representing a legitimate NAIF ID '    //
     .                       'nor an object name recognized in '     //
     .                       'SPICE.'                                )
               CALL ERRCH  ( '#', CLVALS(I)                          )
               CALL ERRCH  ( '#', SB2KEY                             )
               CALL SIGERR ( 'SPICE(BADBODY2SPEC)'                   )
            END IF

         ELSE

            CALL BODC2N ( BODID(2), HWORD, FOUND )
            IF ( FOUND ) THEN
               BODNAM(2) = HWORD
            END IF

         END IF

      END IF

C
C     Was the second frame name provided on the command line?
C
      FRAME(2) = ' '

      I = ISRCHC( FR2KEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         FRAME(2) = CLVALS(I)
         CALL NAMFRM( FRAME(2), FRAMID )

         IF ( FRAMID .EQ. 0 ) THEN
            CALL SETMSG ( 'Cannot recognize frame ''#'' provided '   //
     .                    'on the command line after ''#'' key.'     )
            CALL ERRCH  ( '#', FRAME(2)                              )
            CALL ERRCH  ( '#', FR2KEY                                )
            CALL SIGERR ( 'SPICE(BADFRAME2NAME)'                     )
         END IF

      END IF

C
C     Were begin and end times provided on the command line?
C
      TIME(1) = ' '

      I = ISRCHC( BEGKEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN
         TIME(1) = CLVALS(I)
         CALL STR2ET( CLVALS(I), ET(1) )
      END IF

      TIME(2) = ' '

      I = ISRCHC( ENDKEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN
         TIME(2) = CLVALS(I)
         CALL STR2ET( CLVALS(I), ET(2) )
      END IF

C
C     Check that begin time is less than the end time.
C
      IF ( TIME(1) .NE. ' ' .AND. TIME(2) .NE. ' ' ) THEN

         IF ( ET(2) .LT. ET(1) ) THEN
            CALL SETMSG ( 'Specified start time ''#'' is greater '   //
     .                    'than specified stop time ''#''.'          )
            CALL ERRCH  ( '#', TIME(1)                               )
            CALL ERRCH  ( '#', TIME(2)                               )
            CALL SIGERR ( 'SPICE(INCONSISTENTTIMES)'                 )
         END IF

      END IF

C
C     Sanity check: body should be distinct from center for all possible
C     input combinations (-b1/-c1, -b2/-c2, -b1/-c2 and -b2/-c1).
C
      IF      ( BODNAM(1) .NE. ' ' .AND. CENNAM(1) .NE. ' ' ) THEN
         IF   ( BODID(1) .EQ. CENID(1) ) THEN 
            CALL SETMSG ( 'Body and center specified on the '        //
     .                    'command line line must be distinct. '     //
     .                    'They were ''#''(#) and ''#''(#).'         )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', CENNAM(1)                             )
            CALL ERRINT ( '#', CENID(1)                              )
            CALL SIGERR ( 'SPICE(SAMEBODY1CENTER1)'                  )
         END IF
      ELSE IF ( BODNAM(2) .NE. ' ' .AND. CENNAM(2) .NE. ' ' ) THEN
         IF   ( BODID(2) .EQ. CENID(2) ) THEN
            CALL SETMSG ( 'Body and center specified on the '        //
     .                    'command line line must be distinct. '     //
     .                    ' They were ''#''(#) and ''#''(#).'        )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', CENNAM(2)                             )
            CALL ERRINT ( '#', CENID(2)                              )
            CALL SIGERR ( 'SPICE(SAMEBODY2CENTER2)'                  )
         END IF
      ELSE IF ( BODNAM(1) .NE. ' ' .AND. CENNAM(2) .NE. ' ' 
     .                           .AND. CENNAM(1) .EQ. ' ' ) THEN
         IF   ( BODID(1) .EQ. CENID(2) ) THEN
            CALL SETMSG ( 'Body and center specified on the '        //
     .                    'command line line must be distinct. '     //
     .                    ' They were ''#''(#) and ''#''(#).'        )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', CENNAM(2)                             )
            CALL ERRINT ( '#', CENID(2)                              )
            CALL SIGERR ( 'SPICE(SAMEBODY1CENTER2)'                  )
         END IF
      ELSE IF ( BODNAM(2) .NE. ' ' .AND. CENNAM(1) .NE. ' ' 
     .                           .AND. CENNAM(2) .EQ. ' ' ) THEN
         IF   ( BODID(2) .EQ. CENID(1) ) THEN
            CALL SETMSG ( 'Body and center specified on the '        //
     .                    'command line line must be distinct. '     //
     .                    ' They were ''#''(#) and ''#''(#).'        )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', CENNAM(1)                             )
            CALL ERRINT ( '#', CENID(1)                              )
            CALL SIGERR ( 'SPICE(SAMEBODY2CENTER1)'                  )
         END IF
      END IF

C
C     Before we move on to processing the final command line keys that
C     determine how many steps and/or steps of what size we will do
C     in this comparison, we will need to fill in all ``blanks'', i.e.
C     any center, body, frame and coverage inputs that were missing 
C     on the command line.
C

C
C     If only one body name/ID was provided, set the other one to be
C     the same.
C
      IF      ( BODNAM(1) .EQ. ' ' .AND. BODNAM(2) .NE. ' ' ) THEN

         BODID(1)  = BODID(2)
         BODNAM(1) = BODNAM(2)

      ELSE IF ( BODNAM(2) .EQ. ' ' .AND. BODNAM(1) .NE. ' ' ) THEN

         BODID(2)  = BODID(1)
         BODNAM(2) = BODNAM(1)

      END IF

C
C     If only one center name/ID was provided, set the other one to be
C     the same.
C
      IF      ( CENNAM(1) .EQ. ' ' .AND. CENNAM(2) .NE. ' ' ) THEN

         CENID(1)  = CENID(2)
         CENNAM(1) = CENNAM(2)

      ELSE IF ( CENNAM(2) .EQ. ' ' .AND. CENNAM(1) .NE. ' ' ) THEN

         CENID(2)  = CENID(1)
         CENNAM(2) = CENNAM(1)

      END IF

C
C     If only one frame name was provided, set the other one to be the
C     same.
C
      IF      ( FRAME(1) .EQ. ' ' .AND. FRAME(2) .NE. ' ' ) THEN

         FRAME(1) = FRAME(2)

      ELSE IF ( FRAME(2) .EQ. ' ' .AND. FRAME(1) .NE. ' ' ) THEN

         FRAME(2)  = FRAME(1)

      END IF

C
C     Check if at least one body, center, and frame were provided on
C     the command line. If not, obtain default values by looking at the
C     first SPK file.
C
      IF      ( ( BODNAM(1) .EQ. ' ' .AND. BODNAM(2) .EQ. ' ' ) .OR.
     .          ( CENNAM(1) .EQ. ' ' .AND. CENNAM(2) .EQ. ' ' ) .OR.
     .          ( FRAME(1)  .EQ. ' ' .AND. FRAME(2) .EQ. ' '  )   ) THEN

C
C        We don't have complete body-center-frame triplets on the
C        command line and need to get some defaults. Open the first SPK
C        and look through it.
C
C        If first, second, or both body IDs were specified on the
C        command line, then center and frame from the segment for this
C        body closest to the end of the file will be picked as default
C        values.
C        
C        If neither first nor second body ID was specified on the
C        command line and SPK contains segments for one or more
C        spacecraft, the body, center, and frame from the spacecraft
C        segment closest to the end of the file will be picked as
C        default values.
C
C        If neither first nor second body ID was specified on the
C        command line and SPK contains no spacecraft segments, the
C        body, center, and frame from the very last segment of the file
C        will be picked as default values.
C

C
C        Zero out descriptor buffers for last segment, last s/c segment
C        and last segment for specified body. Note that SPK type
C        element (ICXXXX(4)) cannot be 0 for any real SPK segment; this
C        property will be relied upon in checks in the loop below to
C        determine if any of these descriptors have already been set.
C
         CALL FILLI ( 0, NI, ICLSTN )
         CALL FILLI ( 0, NI, ICLSTS )
         CALL FILLI ( 0, NI, ICLSTB )

C
C        Open first SPK file and search it in backward order.
C
         CALL DAFOPR ( SPK(1), HANDLE )
         CALL DAFBBS ( HANDLE )
         CALL DAFFPA ( FOUND )

         DO WHILE ( FOUND )

C
C           Fetch and unpack the segment descriptor.
C
            CALL DAFGS ( DESCR )
            CALL DAFUS ( DESCR, ND, NI, DC, IC )

C
C           Save integer components of the last descriptor.
C
            IF ( ICLSTN(4) .EQ. 0 ) THEN
               CALL MOVEI( IC, NI, ICLSTN )
            END IF

C
C           Save integer components of the last descriptor for a
C           spacecraft.
C
            IF ( ICLSTS(4) .EQ. 0 .AND. IC(1) .LT. 0 ) THEN
               CALL MOVEI( IC, NI, ICLSTS )
            END IF

C
C           Save integer components of the data descriptor for
C           the specified body.
C
            IF ( ICLSTB(4) .EQ. 0 .AND. BODNAM(1) .NE. ' ' .AND. 
     .                                  BODID(1)  .EQ. IC(1)     ) THEN
               CALL MOVEI( IC, NI, ICLSTB )
            END IF

C
C           Find next segment.
C
            CALL DAFFPA ( FOUND )
            
         END DO
 
C
C        Release the file.
C        
         CALL DAFCLS ( HANDLE )

C
C        Set default values based on priorities described above and the
C        descriptor data collected in the loop.
C
         IF ( BODNAM(1) .NE. ' ' ) THEN

C
C           Check if any segments for specified body were found. If
C           yes, set defaults. If no, complain and stop.
C
            IF ( ICLSTB(4) .NE. 0 ) THEN
               CALL MOVEI( ICLSTB, NI, IC )
            ELSE
               CALL SETMSG ( 'SPK file ''#'' does not contain any '  //
     .                       'data for body ''#''(#) specified '     //
     .                       'on the command line,'                  )
               CALL ERRCH  ( '#', SPK(1)                             )
               CALL ERRCH  ( '#', BODNAM(1)                          )
               CALL ERRINT ( '#', BODID(1)                           )
               CALL SIGERR ( 'SPICE(1NODATAFORBODY)'                 )
            END IF

         ELSE IF ( ICLSTS(4) .NE. 0 ) THEN

C
C           Set defaults to the values from the last segment for a
C           spacecraft.
C
            CALL MOVEI( ICLSTS, NI, IC )

         ELSE

C
C           Set defaults to the values from the last segment
C
            CALL MOVEI( ICLSTN, NI, IC )

         END IF

C
C        Do a sanity check. At this point descriptor containing defaults
C        (IC) should have been set to something meaningful therefore
C        IC(4) should be non-zero.
C
         IF ( IC(4) .EQ. 0 ) THEN
            CALL SETMSG ( 'Cannot retrieve default values from SPK ' //
     .                    'file ''#''. It either is damaged or '     //
     .                    'contains no data segments.'               )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL SIGERR ( 'SPICE(CANNOTGETDEFAULTS)'                 )
         END IF

C
C        Set default body.
C
         IF ( BODNAM(1) .EQ. ' ' ) THEN
            BODID(1)  = IC(1)
            BODID(2)  = IC(1)
            CALL BODC2N ( BODID(1), BODNAM(1), FOUND )
            IF ( .NOT. FOUND ) THEN
               CALL INTSTR ( IC(1), BODNAM(1) )
            END IF
            BODNAM(2) = BODNAM(1)
         END IF

C
C        Set default center.
C
         IF ( CENNAM(1) .EQ. ' ' ) THEN
            CENID(1) = IC(2)
            CENID(2) = IC(2)
            CALL BODC2N ( CENID(1), CENNAM(1), FOUND )
            IF ( .NOT. FOUND ) THEN
               CALL INTSTR ( IC(2), CENNAM(1) )
            END IF
            CENNAM(2) = CENNAM(1)
         END IF

C
C        Set default frame.
C
         IF ( FRAME(1) .EQ. ' ' ) THEN
            CALL FRMNAM( IC(3), FRAME(1) )
            IF ( FRAME(1) .EQ. ' ' ) THEN
               CALL SETMSG ( 'Cannot pick default frame for this '   //
     .                       'run. Please, specify the frame '       //
     .                       'relative to which states should be '   //
     .                       'computed using ''#'' or ''#'' '        //
     .                       'command line keys.'                    )
               CALL ERRCH  ( '#', FR1KEY                             )
               CALL ERRCH  ( '#', FR2KEY                             )
               CALL SIGERR ( 'SPICE(CANNOTPICKFRAME)'                )
            END IF
            FRAME(2) = FRAME(1)
         END IF

      END IF

C
C     Now that we have body and center for each pair we can repeat the 
C     same sanity check: body should be distinct from center.
C
      IF      ( BODID(1) .EQ. CENID(1) ) THEN 
 
         CALL SETMSG ( 'Body and center picked from SPK and/or '     //
     .                 'command line line must be distinct. They '   //
     .                 'were ''#''(#) and ''#''(#).'                 )
         CALL ERRCH  ( '#', BODNAM(1)                                )
         CALL ERRINT ( '#', BODID(1)                                 )
         CALL ERRCH  ( '#', CENNAM(1)                                ) 
         CALL ERRINT ( '#', CENID(1)                                 )
         CALL SIGERR ( 'SPICE(SAMEBODYANDCENTER3)'                   )

      ELSE IF ( BODID(2) .EQ. CENID(2) ) THEN

         CALL SETMSG ( 'Body and center picked from SPK and/or '     //
     .                 'command line line must be distinct. They '   //
     .                 'were ''#''(#) and ''#''(#).'                 )
         CALL ERRCH  ( '#', BODNAM(2)                                )
         CALL ERRINT ( '#', BODID(2)                                 )
         CALL ERRCH  ( '#', CENNAM(2)                                )
         CALL ERRINT ( '#', CENID(2)                                 )
         CALL SIGERR ( 'SPICE(SAMEBODYANDCENTER4)'                   )

      END IF

C
C     If either begin or end time was not provided on the command we
C     need to examine both SPKs to determine the range for which do the
C     comparison.
C
      IF ( TIME(1) .EQ. ' ' .OR. TIME(2) .EQ. ' ' ) THEN
         
C
C        Initialize coverage windows for the first and seconds SPKs
C        and for intersection between them.
C
         CALL SSIZED ( WINSIZ,     COVER1 )
         CALL SSIZED ( WINSIZ,     COVER2 )
         CALL SSIZED ( WINSIZ + 2, COVERC )

C
C        Get coverage for the first body from the first SPK file.
C
         CALL SPKCOV ( SPK(1), BODID(1), COVER1 )

C
C        Check if the first SPK provides any coverage for the body
C        of interest.
C
         IF ( CARDD ( COVER1 ) .EQ. 0 ) THEN
            CALL SETMSG ( 'SPK file ''#'' does not contain any '     //
     .                    'data for body ''#''(#) specified '        //
     .                    'on the command line,'                     )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL SIGERR ( 'SPICE(2NODATAFORBODY)'                    )
         END IF

C
C        Get coverage for the second body from the second SPK file.
C
         CALL SPKCOV ( SPK(2), BODID(2), COVER2 )

C
C        Check if the second SPK provides any coverage for the body of
C        interest.
C
         IF ( CARDD ( COVER2 ) .EQ. 0 ) THEN
            CALL SETMSG ( 'SPK file ''#'' does not contain any '     //
     .                    'data for body ''#''(#) specified '        //
     .                    'on the command line,'                     )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL SIGERR ( 'SPICE(3NODATAFORBODY)'                    )
         END IF
         
C
C        Find the intersection of the two coverages.
C
         CALL WNINTD ( COVER1, COVER2, COVERC )

C
C        Check if we have an intersection.
C
         IF ( CARDD ( COVERC ) .EQ. 0 ) THEN

            CALL SETMSG ( 'Coverage for body ''#''(#) provided by '  //
     .                    'SPK ''#'' and coverage for body ''#'''    //
     .                    '(#) provided by SPK ''#'' do not '        //
     .                    'overlap.'                                 )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL SIGERR ( 'SPICE(NOOVERLAP1)'                        )

         END IF

      END IF      

C
C     If begin, end or both times were not set yet, now is the time
C     to do it since we have our defaults in hand.
C
      IF      ( TIME(1) .EQ. ' ' .AND. TIME(2) .EQ. ' ' ) THEN

C
C        If neither begin nor end time are set, we will use the
C        coverage intersection begin and end as boundaries. We just
C        need to make sure that we have only one window.
C
         IF ( CARDD ( COVERC ) .GT. 2 ) THEN

            CALL SETMSG ( 'The intersection of coverage for body '   //
     .                    '''#''(#) provided by '                    //
     .                    'SPK ''#'' and coverage for body ''#'''    //
     .                    '(#) provided by SPK ''#'' includes '      //
     .                    'more than one continuous window. '        )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL SIGERR ( 'SPICE(MORETHAN1INTERVAL1)'                )

         END IF

C
C        Set begin and end time.
C
         ET(1) = COVERC( 1 )
         ET(2) = COVERC( 2 )

      ELSE IF ( TIME(1) .EQ. ' ' ) THEN

C
C        End time was provided while begin time was not. We need to 
C        constrain the coverage intercept by the end time. 
C
         CALL SSIZED ( WINSIZ,  COVER1 )
         CALL APPNDD ( DPMIN(), COVER1 )
         CALL APPNDD ( ET(2),   COVER1 )

         CALL WNINTD ( COVERC, COVER1, COVER2 )

C
C        Check if we have any coverage and if it is exactly one window.
C
         IF      ( CARDD ( COVER2 ) .EQ. 0 ) THEN

            CALL SETMSG ( 'There is no overlap of coverage for body '//
     .                    '''#''(#) provided by '                    //
     .                    'SPK ''#'' and coverage for body ''#'''    //
     .                    '(#) provided by SPK ''#'' before '        //
     .                    '''#''(# TDB seconds).'                    )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL ERRCH  ( '#', TIME(2)                               )
            CALL ERRDP  ( '#', ET(2)                                 )
            CALL SIGERR ( 'SPICE(NOOVERLAP2)'                        )

         ELSE IF ( CARDD ( COVER2 ) .GT. 2 ) THEN

            CALL SETMSG ( 'The intersection of coverage for body '   //
     .                    '''#''(#) provided by '                    //
     .                    'SPK ''#'' and coverage for body ''#'''    //
     .                    '(#) provided by SPK ''#'' before ''#'''   //
     .                    '(# TDB seconds) includes '                //
     .                    'more than one continuous window. '        )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL ERRCH  ( '#', TIME(2)                               )
            CALL ERRDP  ( '#', ET(2)                                 )
            CALL SIGERR ( 'SPICE(MORETHAN1INTERVAL2)'                )

         END IF

C
C        Set begin and end time.
C
         ET(1) = COVER2( 1 )
         ET(2) = COVER2( 2 )

      ELSE IF ( TIME(2) .EQ. ' ' ) THEN

C
C        Begin time was provided while end time was not. We need to 
C        constrain the coverage intercept by the begin time. 
C
         CALL SSIZED ( WINSIZ,  COVER1 )
         CALL APPNDD ( ET(1),   COVER1 )
         CALL APPNDD ( DPMAX(), COVER1 )

         CALL WNINTD ( COVERC, COVER1, COVER2 )

C
C        Check if we have any coverage and if it is exactly one window.
C
         IF      ( CARDD ( COVER2 ) .EQ. 0 ) THEN

            CALL SETMSG ( 'There is no overlap of coverage for body '//
     .                    '''#''(#) provided by '                    //
     .                    'SPK ''#'' and coverage for body ''#'''    //
     .                    '(#) provided by SPK ''#'' after '         //
     .                    '''#''(# TDB seconds).'                    )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL ERRCH  ( '#', TIME(1)                               )
            CALL ERRDP  ( '#', ET(1)                                 )
            CALL SIGERR ( 'SPICE(NOOVERLAP3)'                        )

         ELSE IF ( CARDD ( COVER2 ) .GT. 2 ) THEN

            CALL SETMSG ( 'The intersection of coverage for body '   //
     .                    '''#''(#) provided by '                    //
     .                    'SPK ''#'' and coverage for body ''#'''    //
     .                    '(#) provided by SPK ''#'' after ''#'''    //
     .                    '(# TDB seconds) includes '                //
     .                    'more than one continuous window. '        )
            CALL ERRCH  ( '#', BODNAM(1)                             )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL ERRCH  ( '#', BODNAM(2)                             )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL ERRCH  ( '#', TIME(1)                               )
            CALL ERRDP  ( '#', ET(1)                                 )
            CALL SIGERR ( 'SPICE(MORETHAN1INTERVAL3)'                )

         END IF

C
C        Set begin and end time. 
C
         ET(1) = COVER2( 1 )
         ET(2) = COVER2( 2 )

      END IF

C
C     Set begin and end time in calendar ET format for banner output. 
C
      CALL ETCAL( ET(1), TIME(1) )
      CALL ETCAL( ET(2), TIME(2) )
      TIME(1) = TIME(1)(:RTRIM(TIME(1))) // ' TDB'
      TIME(2) = TIME(2)(:RTRIM(TIME(2))) // ' TDB'

C
C     Was time step or number of steps provided on the command line? If
C     both are specified, time step has higher priority and, for this
C     reason, should be processed first.
C
      I = ISRCHC( STPKEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

C
C        Is the step a DP number?
C
         CALL NPARSD ( CLVALS(I), STEP, ERROR, PTR )

         IF ( PTR .EQ. 0 ) THEN

C
C           Check that step is a positive number and is greater that 
C           the smallest step we can allow.
C
            IF ( STEP .LT. STPTOL ) THEN
               CALL SETMSG ( 'Time step ''#'' specified after ''#'' '//
     .                       'key is smaller than # seconds.'        )
               CALL ERRCH  ( '#', CLVALS(I)                          )
               CALL ERRCH  ( '#', STPKEY                             )
               CALL ERRDP  ( '#', STPTOL                             )
               CALL SIGERR ( 'SPICE(STEPTOOSMALL1)'                  )
            END IF

C
C           Compute the number of steps that will be required to step
C           over the time interval with this step. 
C
            CALL RMAIND ( ET(2) - ET(1), STEP, HDP1, HDP2 )

C
C           If step is greater than time range, we will have only two
C           points. If step overflows maximum integer we reset it to
C           INTMAX-2 and error out later. If remainder is closer than
C           tolerance to zero, we will not introduce "extra" step for
C           the end of the interval. If otherwise we will add an extra
C           step for end of the interval.
C
            IF      ( HDP1 .EQ. 0.D0   ) THEN
               NITR = 2
            ELSE IF ( HDP1 .GT. INTMAX() - 2 ) THEN
               NITR = INTMAX() - 2
            ELSE IF ( HDP2 .LE. STPTOL ) THEN
               NITR = NINT( HDP1 ) + 1
               HDP1 = HDP1 + 1
            ELSE
               NITR = NINT( HDP1 ) + 2
               HDP1 = HDP1 + 2
            END IF

C
C           Check that this number of states will fit into the
C           buffer.
C           
            IF ( NITR .GT. MAXITR ) THEN
               CALL SETMSG ( 'The number of states, #, computed '    //
     .                       'using step of # seconds within time '  //
     .                       'interval from ''#''(# TDB seconds) to '//
     .                       '''#''(# TDB seconds) is '              //
     .                       'greater than can fit into program''s ' //
     .                       'buffers (# states maximum.) Increase ' //
     .                       'step or '                              //
     .                       'make the time window smaller in '      //
     .                       'order to run the program.'             )
               CALL ERRDP  ( '#', HDP1                               )
               CALL ERRDP  ( '#', STEP                               )
               CALL ERRCH  ( '#', TIME(1)                            )
               CALL ERRDP  ( '#', ET(1)                              )
               CALL ERRCH  ( '#', TIME(2)                            )
               CALL ERRDP  ( '#', ET(2)                              )
               CALL ERRINT ( '#', MAXITR                             )
               CALL SIGERR ( 'SPICE(STEPTOOSMALL2)'                  )
            END IF

         ELSE 
            CALL SETMSG ( 'Time step ''#'' specified after ''#'' '   //
     .                    'key is not a DP number.'                  )
            CALL ERRCH  ( '#', CLVALS(I)                             )
            CALL ERRCH  ( '#', STPKEY                                )
            CALL SIGERR ( 'SPICE(NOTANDPNUMBER)'                     )
         END IF
         
      ELSE

C
C        Step was not provided on the command line. What about the
C        number of steps?
C
         I = ISRCHC( NSTKEY, MAXKEY, CLKEYS )

         IF ( CLFLAG(I) ) THEN

C
C           Is the number of step an integer number?
C
            CALL NPARSI ( CLVALS(I), NITR, ERROR, PTR )

            IF ( PTR .EQ. 0 ) THEN

               IF ( NITR .LT. MINITR .OR. NITR .GT. MAXITR ) THEN
                  CALL SETMSG ( 'Number of states must be an '       //
     .                          'integer number between # and '      //
     .                          '#. It was #.'                       )
                  CALL ERRINT ( '#', MINITR                          )
                  CALL ERRINT ( '#', MAXITR                          )
                  CALL ERRINT ( '#', NITR                            )
                  CALL SIGERR ( 'SPICE(BADNOFSTATES)'                )
               END IF

            ELSE 
               CALL SETMSG ( 'Number of states ''#'' specified '     //
     .                       'after ''#''  key is not an integer '   //
     .                       'number.'                               )
               CALL ERRCH  ( '#', CLVALS(I)                          )
               CALL ERRCH  ( '#', NSTKEY                             )
               CALL SIGERR ( 'SPICE(NOTANINTEGERNUMBER)'             )
            END IF

         ELSE

C
C           Set number of states to the default number.
C           
            IF ( ET(2) .EQ. ET(1) ) THEN
               NITR = MINITR
            ELSE
               NITR = DEFITR
            END IF

         END IF

C
C        Calculate step.
C
         STEP = ( ET(2) - ET(1) ) / DBLE ( NITR - 1 )
               
      END IF

C
C     Was the type of output specified on the command line?
C
      I = ISRCHC( TYPKEY, MAXKEY, CLKEYS )

      IF ( CLFLAG(I) ) THEN

         DIFTYP = CLVALS(I)

         IF ( .NOT. ( EQSTR( DIFTYP, STSVAL ) .OR. 
     .                EQSTR( DIFTYP, DMPVAL ) .OR. 
     .                EQSTR( DIFTYP, DVFVAL ) .OR. 
     .                EQSTR( DIFTYP, BSCVAL )      ) ) THEN

            CALL SETMSG ( 'Output type ''#'' specified after '       //
     .                    '''#'' key is not recognized. Recognized ' //
     .                    'output types are ''#'', ''#'', ''#'', '   //
     .                    'and ''#''.'                               )
            CALL ERRCH  ( '#', CLVALS(I)                             )
            CALL ERRCH  ( '#', TYPKEY                                )
            CALL ERRCH  ( '#', BSCVAL                                )
            CALL ERRCH  ( '#', STSVAL                                )
            CALL ERRCH  ( '#', DMPVAL                                )
            CALL ERRCH  ( '#', DVFVAL                                )
            CALL SIGERR ( 'SPICE(BADOUTPUTTYPE)'                     )

         END IF

      ELSE

         DIFTYP = BSCVAL

      END IF

C
C     If simple dump of the differences was requested we need to check
C     whether output time format was provided on the command line.
C
      TIMFMT = ' '
      
      IF ( EQSTR( DIFTYP, DMPVAL ) .OR. EQSTR( DIFTYP, DVFVAL ) ) THEN

         I = ISRCHC( FMTKEY, MAXKEY, CLKEYS )
         
         IF ( CLFLAG(I) ) THEN

            TIMFMT = CLVALS(I)

C
C           In this incarnation of the program we are not going to try
C           to verify that the format is OK at the time when we process
C           command line. We will let TIMOUT fail when it's called for
C           the first time down stream from here. The only thing that
C           makes sense to check for is if the format string is non
C           blank.
C
            IF ( TIMFMT .EQ. ' ' ) THEN
               CALL SETMSG ( 'Output time format specified after '   //
     .                       '''#'' key is blank.'                   )
               CALL ERRCH  ( '#', FMTKEY                             )
               CALL SIGERR ( 'SPICE(BLANKTIMEFORMAT)'                )
            END IF
            
         END IF

      END IF

C
C     Check out.
C
      CALL CHKOUT( 'CHWCML' )

      END
