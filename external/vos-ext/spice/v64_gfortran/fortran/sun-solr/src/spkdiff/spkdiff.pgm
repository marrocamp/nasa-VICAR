C$Procedure   SPKDIFF ( Compare two SPK files. )
 
      PROGRAM SPKDIFF

      IMPLICIT NONE
 
C$ Abstract
C
C     SPKDIFF is a program that finds differences between geometric
C     states computed from two SPK files and either displays these
C     differences or shows statistics about them. 
C
C     For complete information about the program see SPKDIFF User's
C     Guide.
C  
C$ Disclaimer
C
C     THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
C     CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
C     GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
C     ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
C     PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
C     TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
C     WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
C     PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
C     SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
C     SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
C
C     IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
C     BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
C     LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
C     INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
C     REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
C     REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
C
C     RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
C     THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
C     CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
C     ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
C
C$ Author_and_Institution
C
C     B.V. Semenov   (JPL)
C
C$ Version
C
C-    Version 1.0.0, 18-JUL-2006 (BVS).
C
C-&
 
C
C     Global parameters
C
      INCLUDE 'spkdiff.inc'

C
C     Local variables
C
      CHARACTER*(LINSIZ)    INFMSG ( INFCNT )
      CHARACTER*(LINSIZ)    KERNLS
      CHARACTER*(LINSIZ)    LINE
      CHARACTER*(LINSIZ)    SPK    ( 2 )
      CHARACTER*(LINSIZ)    TIME   ( 2 )
      CHARACTER*(LINSIZ)    TIMFMT
      CHARACTER*(WRDSIZ)    BODNAM ( 2 )
      CHARACTER*(WRDSIZ)    CENNAM ( 2 )
      CHARACTER*(WRDSIZ)    DIFTYP
      CHARACTER*(WRDSIZ)    FRAME  ( 2 )
      CHARACTER*(WRDSIZ)    HWORD

      DOUBLE PRECISION      DSCLST ( DSCSIZ, MAXSEG )
      DOUBLE PRECISION      EPOCH  (    MAXITR )
      DOUBLE PRECISION      ET     ( 2 )
      DOUBLE PRECISION      LT
      DOUBLE PRECISION      STATE1 ( 6, MAXITR )
      DOUBLE PRECISION      STATE2 ( 6, MAXITR )
      DOUBLE PRECISION      STEP
      DOUBLE PRECISION      HDP1
      DOUBLE PRECISION      HDP2
      DOUBLE PRECISION      HDP3
      DOUBLE PRECISION      HDP4

      INTEGER               BODID  ( 2 )
      INTEGER               CENID  ( 2 )
      INTEGER               HANDLE
      INTEGER               HANLST ( MAXSEG )
      INTEGER               I
      INTEGER               J
      INTEGER               N
      INTEGER               NITR
      INTEGER               SPKCNT

      INTEGER               DAY
      INTEGER               HOUR
      INTEGER               MINUTS
      INTEGER               SEC
      INTEGER               MSEC

C
C     SPICELIB functions.
C
      DOUBLE PRECISION      SPD
      INTEGER               RTRIM

C
C     Save everything to prevent potential memory problems in f2c'ed
C     version.
C
      SAVE

C
C     Check in.
C
      CALL CHKIN ( PGMNAM )

C
C     Reset default error messages.
C
      CALL ERRPRT (  'SET', 'NONE, SHORT, LONG, TRACEBACK'  )

C
C     Get command line and call the "big kahuna" deal-with-command-line
C     routine and get back all needed setups.
C
      CALL GETCML ( LINE )
      CALL CHWCML ( LINE, SPK, BODNAM, BODID, CENNAM, CENID, 
     .              FRAME, TIME, ET, NITR, STEP, DIFTYP, TIMFMT,
     .              KERNLS )

C
C     OK. We are done with inputs and report about what we are going to
C     compare.
C


      INFMSG(  1 ) = '# '
      INFMSG(  2 ) = '# Comparison of $ ''$''-referenced geometric '
     .//             'states'
      INFMSG(  3 ) = '# '
      INFMSG(  4 ) = '#    of ''$'' ($) relative to ''$'' ($)'
      INFMSG(  5 ) = '#    from SPK ''$'''
      INFMSG(  6 ) = '# '
      INFMSG(  7 ) = '# with $ ''$''-referenced geometric state'
     .//             's'
      INFMSG(  8 ) = '# '
      INFMSG(  9 ) = '#    of ''$'' ($) relative to ''$'' ($)'
      INFMSG( 10 ) = '#    from SPK ''$'''
      INFMSG( 11 ) = '# '
      INFMSG( 12 ) = '# evenly-spaced with $ second ($) step size'
      INFMSG( 13 ) = '# within the time interval'
      INFMSG( 14 ) = '# '
      INFMSG( 15 ) = '#    from ''$'' ($ TDB seconds)'
      INFMSG( 16 ) = '#    to   ''$'' ($ TDB seconds)'
      INFMSG( 17 ) = '# '
      INFMSG( 18 ) = '# using additional data from these kernels'
      INFMSG( 19 ) = '# '
      INFMSG( 20 ) = '#    ''$'''
      INFMSG( 21 ) = '# '

      CALL REPMI ( INFMSG(  2 ), '$', NITR,      INFMSG(  2 ) )
      CALL REPMC ( INFMSG(  2 ), '$', FRAME(1),  INFMSG(  2 ) )

      CALL REPMC ( INFMSG(  4 ), '$', BODNAM(1), INFMSG(  4 ) )
      CALL REPMI ( INFMSG(  4 ), '$', BODID(1),  INFMSG(  4 ) )
      CALL REPMC ( INFMSG(  4 ), '$', CENNAM(1), INFMSG(  4 ) )
      CALL REPMI ( INFMSG(  4 ), '$', CENID(1),  INFMSG(  4 ) )

      CALL REPMC ( INFMSG(  5 ), '$', SPK(1),    INFMSG(  5 ) )

      CALL REPMI ( INFMSG(  7 ), '$', NITR,      INFMSG(  7 ) )
      CALL REPMC ( INFMSG(  7 ), '$', FRAME(2),  INFMSG(  7 ) )

      CALL REPMC ( INFMSG(  9 ), '$', BODNAM(2), INFMSG(  9 ) )
      CALL REPMI ( INFMSG(  9 ), '$', BODID(2),  INFMSG(  9 ) )
      CALL REPMC ( INFMSG(  9 ), '$', CENNAM(2), INFMSG(  9 ) )
      CALL REPMI ( INFMSG(  9 ), '$', CENID(2),  INFMSG(  9 ) )

      CALL REPMC ( INFMSG( 10 ), '$', SPK(2),    INFMSG( 10 ) )

C
C     Step in included into the report as the number of seconds and as
C     #d #h #m #.######s (for more clarity.)
C     
      CALL REPMF ( INFMSG( 12 ), '$', STEP, 15, 'F',  INFMSG( 12 ) )

      CALL RMAIND( STEP,   SPD(), HDP1, HDP2 )
      DAY    = HDP1
      CALL RMAIND( HDP2, 3600.D0, HDP1, HDP3 )
      HOUR   = HDP1
      CALL RMAIND( HDP3,   60.D0, HDP1, HDP4 )
      MINUTS = HDP1
      CALL RMAIND( HDP4,    1.D0, HDP1, HDP2 )
      SEC    = HDP1

      MSEC = NINT( HDP2 * 1000000.D0 )
      IF ( MSEC .EQ. 1000000 ) THEN
         MSEC = 999999
      END IF
      CALL INTSTR( MSEC, HWORD )
      DO WHILE ( RTRIM(HWORD) .LT. 6 )
         CALL PREFIX( '0', 0, HWORD )
      END DO

      LINE   = '#d #h #m #.#s'
      CALL REPMI ( LINE, '#', DAY,    LINE )
      CALL REPMI ( LINE, '#', HOUR,   LINE )
      CALL REPMI ( LINE, '#', MINUTS, LINE )
      CALL REPMI ( LINE, '#', SEC,    LINE )
      CALL REPMC ( LINE, '#', HWORD,  LINE )

      CALL REPMC ( INFMSG( 12 ), '$', LINE,  INFMSG( 12 ) )

      CALL REPMC ( INFMSG( 15 ), '$', TIME(1),   INFMSG( 15 ) )
      CALL REPMF ( INFMSG( 15 ), '$', ET(1), 15, 'F', INFMSG( 15 ) )

      CALL REPMC ( INFMSG( 16 ), '$', TIME(2),   INFMSG( 16 ) )
      CALL REPMF ( INFMSG( 16 ), '$', ET(2), 15, 'F', INFMSG( 16 ) )

C
C     If no additional kernels were provided, we don't report them.
C
      IF ( KERNLS .NE. ' ' ) THEN
         CALL REPMC ( INFMSG( 20 ), '$', KERNLS, INFMSG( 20 ) )
         N = INFCNT
      ELSE
         N = INFCNT - 4
      END IF

C
C     Report all details about comparison to the screen.
C
      DO I = 1, N
         CALL TOSTDO ( INFMSG(I) )
      END DO

C
C     We are done with command line inputs. Time to get to real
C     business.
C

C
C     Calculate times for which we will compute states.
C
      DO J = 0, NITR-2
         EPOCH(J+1) = ET(1) + DBLE(J)*STEP
      END DO
      
      EPOCH(NITR) = ET(2)

C
C     Before we will go ahead, we will do a small sanity check to
C     verify that other kernels provided on the command line and loaded
C     earlier don't contain any SPKs that would allow to compute state
C     for the first and/or second body-center pair.
C
C     This check needs to be done only if we had any SPKs among other
C     kernels.
C
      CALL KTOTAL ( 'SPK', SPKCNT )

      IF ( SPKCNT .GT. 0 ) THEN

         DO J = 1, NITR
         
C
C           Use modified Nat's ZZGEOSEG to determine whether we have
C           enough SPK data loaded to compute geometric state of the
C           first body-center pair at this time without loading the
C           first SPK.
C
            CALL ZZGEOSEG( BODID(1), EPOCH(J), CENID(1), 
     .                                             N, HANLST, DSCLST )
         
            IF ( N .NE. 0 ) THEN

C
C              Yes, we do. We should signal and error and exit.
C
               CALL ETCAL  ( EPOCH(J), LINE )
               CALL SETMSG ( 'Oops ... It looks like we can compute '//
     .                       'geometric state of # with respect to ' //
     .                       '# in ''#'' frame at ''# TDB'' (ET #), '//
     .                       'even without loading the first SPK '   //
     .                       'file ''#''. It means that '            //
     .                       'supporting kernel(s) ''#'' already '   //
     .                       'contain data for this '                //
     .                       'center/body pair.'                     )
               CALL ERRINT ( '#', BODID(1)                           )
               CALL ERRINT ( '#', CENID(1)                           ) 
               CALL ERRCH  ( '#', FRAME(1)                           )
               CALL ERRCH  ( '#', LINE                               )
               CALL ERRDP  ( '#', EPOCH(J)                           )
               CALL ERRCH  ( '#', SPK(1)                             )
               CALL ERRCH  ( '#', KERNLS                             )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN1)'                )
           
            END IF

C
C           Same for the second body/center pair. 
C  
            CALL ZZGEOSEG( BODID(2), EPOCH(J), CENID(2), 
     .                                             N, HANLST, DSCLST )
         
            IF ( N .NE. 0 ) THEN

C
C              Yes, we do. We should signal and error and exit.
C
               CALL ETCAL  ( EPOCH(J), LINE )
               CALL SETMSG ( 'Oops ... It looks like we can compute '//
     .                       'geometric state of # with respect to ' //
     .                       '# in ''#'' frame at ''# TDB'' (ET #), '//
     .                       'even without loading the second SPK '  //
     .                       'file ''#''. It means that '            //
     .                       'supporting kernel(s) ''#'' already '   //
     .                       'contain data for this '                //
     .                       'center/body pair.'                     )
               CALL ERRINT ( '#', BODID(2)                           )
               CALL ERRINT ( '#', CENID(2)                           )
               CALL ERRCH  ( '#', FRAME(2)                           )
               CALL ERRCH  ( '#', LINE                               )
               CALL ERRDP  ( '#', EPOCH(J)                           )
               CALL ERRCH  ( '#', SPK(2)                             ) 
               CALL ERRCH  ( '#', KERNLS                             )
               CALL SIGERR ( 'SPICE(JEOPARDIZEDRUN2)'                )
           
            END IF

         END DO

      END IF

C
C     Load first SPK file and compute NITR states from it.
C
      CALL SPKLEF( SPK(1), HANDLE )
      
      DO J = 1, NITR
         
C
C        Use modified Nat's ZZGEOSEG to determine whether we have 
C        enough SPK data loaded to compute geometric state at this
C        time.
C
         CALL ZZGEOSEG( BODID(1), EPOCH(J), CENID(1), 
     .                                           N, HANLST, DSCLST )
         
         IF ( N .EQ. 0 ) THEN

C
C           No, we don't. In this version of the program we signal
C           and error and exit.
C
            CALL ETCAL  ( EPOCH(J), LINE )
            CALL SETMSG ( 'Geometric state of # with respect to '    //
     .                    '# in ''#'' frame at ''# TDB'' (ET #), '   //
     .                    'which is within specified interval '      //
     .                    'of interest, cannot be computed due '     //
     .                    'to insufficient data in the first SPK '   //
     .                    'file ''#''.'                              )
            CALL ERRINT ( '#', BODID(1)                              )
            CALL ERRINT ( '#', CENID(1)                              )
            CALL ERRCH  ( '#', FRAME(1)                              )
            CALL ERRCH  ( '#', LINE                                  )
            CALL ERRDP  ( '#', EPOCH(J)                              )
            CALL ERRCH  ( '#', SPK(1)                                )
            CALL SIGERR ( 'SPICE(UNSUFFSPK1DATA)'                    )
           
         END IF

C
C        Thought the test above was incomplete, we may a feel a 
C        bit more comfortable when we call SPKGEO now (there can
C        still be cases when position in one of the segments found
C        ZZGEOSEG was with respect to a frame orientation for which
C        cannot be determined using loaded PCK/CK/FRAMES data, but
C        we will leave it up to SPKGEO to determine this.)
C
         CALL SPKGEO ( BODID(1), EPOCH(J), FRAME(1), CENID(1), 
     .                                               STATE1(1,J), LT )

      END DO

C
C     We are done with the first file. Unload it.
C
      CALL SPKUEF( HANDLE )

C
C     Load second SPK file and compute NITR states from it.
C
      CALL SPKLEF( SPK(2), HANDLE )
      
      DO J = 1, NITR

C
C        Use modified Nat's ZZGEOSEG to determine whether we have 
C        enough SPK data loaded to compute geometric state at this
C        time.
C
         CALL ZZGEOSEG( BODID(2), EPOCH(J), CENID(2), 
     .                                             N, HANLST, DSCLST )
         
         IF ( N .EQ. 0 ) THEN

C
C           No, we don't. In this version of the program we signal
C           and error and exit.
C
            CALL ETCAL  ( EPOCH(J), LINE )
            CALL SETMSG ( 'Geometric state of # with respect to '    //
     .                    '# in ''#'' frame at ''# TDB'' (ET #), '   //
     .                    'which is within specified interval '      //
     .                    'of interest, cannot be computed due '     //
     .                    'to insufficient data in the second SPK '  //
     .                    'file ''#''.'                              )
            CALL ERRINT ( '#', BODID(2)                              )
            CALL ERRINT ( '#', CENID(2)                              )
            CALL ERRCH  ( '#', FRAME(2)                              )
            CALL ERRCH  ( '#', LINE                                  )
            CALL ERRDP  ( '#', EPOCH(J)                              )
            CALL ERRCH  ( '#', SPK(2)                                )
            CALL SIGERR ( 'SPICE(UNSUFFSPK2DATA)'                    )
           
         END IF

C
C        Thought the test above was incomplete, we may a feel a 
C        bit more comfortable when we call SPKGEO now (there can
C        still be cases when position in one of the segments found
C        ZZGEOSEG was with respect to a frame orientation for which
C        cannot be determined using loaded PCK/CK/FRAMES data, but
C        we will leave it up to SPKGEO to determine this.)
C
         CALL SPKGEO ( BODID(2), EPOCH(J), FRAME(2), CENID(2), 
     .                                               STATE2(1,J), LT )

      END DO

C
C     We are done with the second file. Unload it.
C
      CALL SPKUEF( HANDLE )

C
C     Pass state tables to the routine that will do analysis of the
C     differences and will print them to the screen.
C
      CALL STDIFF ( STATE1, STATE2, NITR, EPOCH, DIFTYP, TIMFMT )

C
C     Check out.
C
      CALL CHKOUT( PGMNAM )

C
C     We are done. :-)
C
      END
