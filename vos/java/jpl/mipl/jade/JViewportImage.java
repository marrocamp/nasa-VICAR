/*
 * MODIFIED FROM:
 *
 * @(#)JViewport.java	1.85 00/05/02
 *
 * Copyright 1997-2000 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * This software is the proprietary information of Sun Microsystems, Inc.  
 * Use is subject to license terms.
 * 
 */

package jpl.mipl.jade;

import javax.swing.*;

import java.awt.*;
import java.awt.event.*;
import java.applet.Applet;
import javax.swing.plaf.ViewportUI;

import javax.swing.event.*;
import javax.swing.border.*;
import javax.accessibility.*;


import java.io.Serializable;

import jpl.mipl.jade.util.RectRegion;

/**
 * Exactly like <code>JViewport</code> except that diagonal scrolls are
 * supported with blits, enabling "mouse pan" without repainting the entire
 * image.
 * <p>
 * Implementation of this class was exceedingly difficult due to implementation
 * issues in Swing that prevent easy subclassing of JViewport.  Much of the
 * code had to be re-copied just to change one method
 * (<code>windowBlitPaint</code).  This would all be trivially solved by making
 * certain items protected instead of private in the base JViewport.
 * <p>
 * The change to support diagonal scrolling is trivial and amounts to keeping
 * track of the L-shaped expose area and calling two repaints, instead of a
 * single repaint covering the bounding box of the L.  It should be in the
 * main implementation.
 * <p>
 * See Sun Bug ID's 4478765 and 4486696, which have been inexplicably ignored
 * by Sun for six and a half years now, since they were submitted in August
 * 2001 (!!).
 * <p>
 * Note:  This implementation is based on JDK 1.3's JViewport.  It really
 * should be updated to newer implementations.  But, it still works, so that
 * is a low priority, given the difficulty of doing so.  It's possible the
 * problem (either of diagonal scrolling or subclassing) is fixed in JDK 6
 * but I have not looked - they were not fixed as of JDK 5.
 * <p>
 * <p>
 * Another change from <code>JViewport</code> is to enable implementation
 * of "viewport within viewport" when inner viewport is of the size of 
 * the view it manages while outer viewport is of the size of the visible
 * rectangle.  In our application domain, we use inner
 * viewport for stereo disparity adjustment while outer viewport is used 
 * for scrolling.  To make that work, we changed from using hardcoded
 * (0,0) as an origin and component's width and height to visible rectangle
 * coordinates via {@link javax.swing.JComponent#getVisibleRect()} in 
 * determining extent of certain paint or copy operations.
 * Note that this change might not be complete, the rationale was to
 * just make it work for our purposes and more extensive evaluation and
 * testing will be required to determine the complete and proper set
 * of changes required to switch to using {@link javax.swing.JComponent#getVisibleRect()}
 * instead of component coordinates.
 * <p/>
 * The rest is copied verbatim from <code>JViewport</code>:
 * <p>
 * The "viewport" or "porthole" through which you see the underlying
 * information. When you scroll, what moves is the viewport. It is like
 * peering through a camera's viewfinder. Moving the viewfinder upwards
 * brings new things into view at the top of the picture and loses
 * things that were at the bottom.
 * <p>
 * By default, <code>JViewport</code> is opaque. To change this, use the
 * <code>setOpaque</code> method.
 * <p>
 * <b>NOTE:</b>We have implemented a faster scrolling algorithm that
 * does not require a buffer to draw in. The algorithm works as follows:
 * <ol><li>The view and parent view and checked to see if they are
 * <code>JComponents</code>,
 * if they aren't, stop and repaint the whole viewport.
 * <li>If the viewport is obscured by an ancestor, stop and repaint the whole
 * viewport.
 * <li>Compute the region that will become visible, if it is as big as
 * the viewport, stop and repaint the whole view region.
 * <li>Obtain the ancestor Windows graphics and do a <code>copyArea</code>
 * on the scrolled region.
 * <li>Message the view to repaint the newly visible region.
 * <li>The next time paint is invoked on the viewport, if the clip region
 * is smaller than the viewport size a timer is kicked off to repaint the
 * whole region.
 * </ol>
 * In general this approach is much faster. Compared to the backing store
 * approach this avoids the overhead of maintaining an offscreen buffer and
 * having to do two <code>copyArea</code>s.
 * Compared to the non backing store case this
 * approach will greatly reduce the painted region.
 * <p>
 * This approach can cause slower times than the backing store approach
 * when the viewport is obscured by another window, or partially offscreen.
 * When another window
 * obscures the viewport the copyArea will copy garbage and a
 * paint event will be generated by the system to inform us we need to
 * paint the newly exposed region. The only way to handle this is to
 * repaint the whole viewport, which can cause slower performance than the
 * backing store case. In most applications very rarely will the user be
 * scrolling while the viewport is obscured by another window or offscreen,
 * so this optimization is usually worth the performance hit when obscured.
 * <strong>Warning:</strong>
 * Serialized objects of this class will not be compatible with
 * future Swing releases.  The current serialization support is appropriate
 * for short term storage or RMI between applications running the same
 * version of Swing.  A future release of Swing will provide support for
 * long term persistence.
 *
 * @version 1.85 05/02/00
 * @author Hans Muller
 * @author Philip Milne
 * @author Bob Deen, JPL
 * @see JScrollPane
 */
public class JViewportImage extends JViewport
{

    // FORTUNATELY, these private variables (from JViewport) are used *only*
    // in code which is repeated in this class.  So the fact that they're
    // different in here from the versions in the superclass shouldn't hurt
    // us.  Hopefully.  :-(

    // Changed private variables and functions to protected.  This would
    // allow an extension of JViewportImage in a meaningful way. -ozp  

    /**
     * This is set to true in <code>setViewPosition</code>
     * if doing a window blit.
     */
    protected transient boolean repaintAll;

    /**
     * This is set to true in paint, if <code>repaintAll</code>
     * is true and the clip rectangle does not match the bounds.
     * If true, and scrolling happens the
     * repaint manager is not cleared which then allows for the repaint
     * previously invoked to succeed.
     */
    protected transient boolean waitingForRepaint;

    /**
     * Instead of directly invoking repaint, a <code>Timer</code>
     * is started and when it fires, repaint is invoked.
     */
    protected transient Timer repaintTimer;

    /** Creates a <code>JViewport</code>. */
    public JViewportImage() {
        super();
    }

    /**
     * Only used by the paint method below.
     */
    protected Point getViewLocation() {
        Component view = getView();
        if (view != null) {
            return view.getLocation();
        }
        else {
            return new Point(0,0);
        }
    }

    /**
     * Paint just the recently exposed part, using the backing store
     * to "blit" the remainder.
     * <blockquote>
     * The term "blit" is the pronounced version of the PDP-10
     * BLT (BLock Transfer) instruction, which copied a block of
     * bits. (In case you were curious.)
     * </blockquote>
     *
     * @param g the <code>Graphics</code> context within which to paint
     */
    public void paint(Graphics g)
    {
        int width = getWidth();
        int height = getHeight();

        if ((width <= 0) || (height <= 0)) {
            return;
        }

	if (repaintAll) {
	    repaintAll = false;
	    Rectangle clipB = g.getClipBounds();
	    if (clipB.width < getWidth() ||
		clipB.height < getHeight()) {
		waitingForRepaint = true;
		if (repaintTimer == null) {
		    repaintTimer = createRepaintTimer();
		}
		repaintTimer.stop();
		repaintTimer.start();
		// We really don't need to paint, a future repaint will
		// take care of it, but if we don't we get an ugly flicker.
	    }
	    else {
		if (repaintTimer != null) {
		    repaintTimer.stop();
		}
		waitingForRepaint = false;
	    }
	}
	else if (waitingForRepaint) {
	    // Need a complete repaint before resetting waitingForRepaint
	    // !!!! ozp
	    // Change from using components width and height to
	    // component's visible rectangle width and height.   This is 
	    // necessary for proper implementation of "viewport within viewport"
	    // when inner viewport is of size of the view it manages but
	    // the visible rectangle is of the size of outer viewport.
	    Rectangle clipB = g.getClipBounds();
	    if (clipB.width >= getVisibleRect().width &&
		clipB.height >= getVisibleRect().height) {
	    //if (clipB.width >= getWidth() &&
		//clipB.height >= getHeight()) {
		waitingForRepaint = false;
		repaintTimer.stop();
	    }
	}

        super.paint(g);
        lastPaintPosition = getViewLocation();
        return;

    }

    protected final boolean isBlitting() {
        Component view = getView();
        return (getScrollMode() == BLIT_SCROLL_MODE) && 
	       (view instanceof JComponent) && ((JComponent)view).isOpaque();
    }

    /**
     * Sets the view coordinates that appear in the upper left
     * hand corner of the viewport, does nothing if there's no view.
     *
     * @param p  a <code>Point</code> object giving the upper left coordinates
     */
    public void setViewPosition(Point p) 
    {
        Component view = getView();
        if (view == null) {
	    return;
	}
	
	int oldX, oldY, x = p.x, y = p.y;

	/* Collect the old x,y values for the views location
	 * and do the song and dance to avoid allocating 
	 * a Rectangle object if we don't have to.
	 */
	if (view instanceof JComponent) {
	    JComponent c = (JComponent)view;
	    oldX = c.getX();
	    oldY = c.getY();
	}
	else {
	    Rectangle r = view.getBounds();
	    oldX = r.x;
	    oldY = r.y;
	}

	/* The view scrolls in the opposite direction to mouse 
	 * movement.
	 */
	int newX = -x;
	int newY = -y;
	
	if ((oldX != newX) || (oldY != newY)) {
	    if (!waitingForRepaint && isBlitting() && canUseWindowBlitter()) {
		Graphics g = getGraphics();
		flushViewDirtyRegion(g);
		// This calls setBounds(), and then repaint().
                view.setLocation(newX, newY);
		// The cast to JComponent here is valid, if view is not 
		// a JComponent, isBlitting will return false.
		g.setClip(0,0,getWidth(), Math.min(getHeight(),
				 ((JComponent)view).getHeight()));
		// Forces a repaint of the whole component on the next
		// call to paint.
		repaintAll = windowBlitPaint(g);
		g.dispose();
		RepaintManager rm = RepaintManager.currentManager(this);
		rm.markCompletelyClean((JComponent)getParent());
		rm.markCompletelyClean(this);
		rm.markCompletelyClean((JComponent)view);
	    }
	    else {
		scrollUnderway = true;
		// This calls setBounds(), and then repaint().
		view.setLocation(newX, newY);
		repaintAll = false;
	    }
	    fireStateChanged();
	}
    }

    /**
     * Computes the parameters for a blit where the backing store image
     * currently contains <code>oldLoc</code> in the upper left hand corner
     * and we're scrolling to <code>newLoc</code>.
     * The parameters are modified
     * to return the values required for the blit.
     * @param dx  the horizontal delta
     * @param dy  the vertical delta
     * @param blitFrom the <code>Point</code> we're blitting from
     * @param blitTo the <code>Point</code> we're blitting to
     * @param blitSize the <code>Dimension</code> of the area to blit
     * @param blitPaintX the area to repaint due to dx.  May be empty.
     * @param blitPaintY the area to repaint due to dy.  May be empty.
     * @return  true if the parameters are modified and we're ready to blit;
     *		false otherwise
     */
    protected boolean computeBlit(
        int dx,
        int dy,
        Point blitFrom,
        Point blitTo,
        Dimension blitSize,
        Rectangle blitPaintX,
        Rectangle blitPaintY)
    {
        int dxAbs = Math.abs(dx);
        int dyAbs = Math.abs(dy);

        // !!!! ozp
   		// Change from using components width and height to
	    // component's visible rectangle width and height.   This is 
	    // necessary for proper implementation of "viewport within viewport"
	    // when inner viewport is of size of the view it manages but
	    // the visible rectangle is of the size of outer viewport.        
        //Dimension extentSize = getExtentSize();
        Rectangle visibleRect = getVisibleRect();
        Dimension extentSize = new Dimension(visibleRect.width, visibleRect.height);

	if (dyAbs >= extentSize.height || dxAbs >= extentSize.width)
	    return false;

	// blitPaintY is slightly different from blitPaintX because the
	// overlap goes on the Y version... so the X one must compensate.

        if (dy < 0) {
            blitFrom.y = -dy;
            blitTo.y = 0;
            blitPaintY.y = extentSize.height + dy;
	    blitPaintX.y = 0;
        }
        else {
            blitFrom.y = 0;
            blitTo.y = dy;
            blitPaintY.y = 0;
	    blitPaintX.y = dy;
        }

        if (dx < 0) {
            blitFrom.x = -dx;
            blitTo.x = 0;
            blitPaintX.x = extentSize.width + dx;
        }
        else {
            blitFrom.x = 0;
            blitTo.x = dx;
            blitPaintX.x = 0;
        }

        blitSize.width = extentSize.width - dxAbs;
        blitSize.height = extentSize.height - dyAbs;

        blitPaintY.x = 0;
        blitPaintY.width = extentSize.width;
        blitPaintY.height = dyAbs;

        // blitPaintX.y is set up above to skip the overlap area
        blitPaintX.width = dxAbs;
        blitPaintX.height = extentSize.height - dyAbs;	// skip overlap

		// !!!! ozp
        //Apply visibleRect position offset.
        //Sun's implementation of computeBlit() doesn't take
        //this offset into account
        Rectangle rect = getVisibleRect();
        blitFrom.x += visibleRect.x;
        blitFrom.y += visibleRect.y;
        blitTo.x += visibleRect.x;
        blitTo.y += visibleRect.y;
        
        blitPaintX.x +=visibleRect.x;
        blitPaintX.y +=visibleRect.y;
        blitPaintY.x +=visibleRect.x;
        blitPaintY.y +=visibleRect.y;
        
        return true;
    }

    protected Timer createRepaintTimer() {
	Timer timer = new Timer(300, new ActionListener() {
	    public void actionPerformed(ActionEvent ae) {
		// waitingForRepaint will be false if a paint came down
		// with the complete clip rect, in which case we don't
		// have to cause a repaint.
		if (waitingForRepaint) {
		    repaint();
		}
	    }
	});
	timer.setRepeats(false);
	return timer;
    }

    /**
     * If the repaint manager has a dirty region for the view, the view is
     * asked to paint.
     *
     * @param g  the <code>Graphics</code> context within which to paint
     */
    protected void flushViewDirtyRegion(Graphics g) {
	RepaintManager rm = RepaintManager.currentManager(this);
	JComponent view = (JComponent) getView();
	Rectangle dirty;

	dirty = rm.getDirtyRegion(view);
	if(dirty != null && dirty.width > 0 && dirty.height > 0) {
	    dirty.x += view.getX();
	    dirty.y += view.getY();
	    Rectangle clip = g.getClipBounds();
	    if (clip == null) {
		// Only happens in 1.2
		g.setClip(0, 0, getWidth(), getHeight());
	    }
	    g.clipRect(dirty.x, dirty.y, dirty.width, dirty.height);
	    paintView(g);
	}		
    }

    /**
     * Used when blitting.
     *
     * @param g  the <code>Graphics</code> context within which to paint
     * @return true if blitting succeeded; otherwise false
     */
    protected boolean windowBlitPaint(Graphics g) {
	int width = getWidth();
        int height = getHeight();

        if ((width == 0) || (height == 0)) {
            return false;
        }
		
	boolean retValue;
	RepaintManager rm = RepaintManager.currentManager(this);
	JComponent view = (JComponent) getView();

	if (lastPaintPosition == null ||
	    lastPaintPosition.equals(getViewLocation())) {
	    paintView(g);
	    retValue = false;
	} else {
	    // The image was scrolled. Manipulate the backing store and flush
	    // it to g.
	    Point blitFrom = new Point();
	    Point blitTo = new Point();
	    Dimension blitSize = new Dimension();
	    Rectangle blitPaintX = new Rectangle();
	    Rectangle blitPaintY = new Rectangle();

	    Point newLocation = getViewLocation();
	    int dx = newLocation.x - lastPaintPosition.x;
	    int dy = newLocation.y - lastPaintPosition.y;
	    boolean canBlit = computeBlit(dx, dy, blitFrom, blitTo, blitSize,
					  blitPaintX, blitPaintY);
	    if (!canBlit) {
		paintView(g);
		retValue = false;
	    } else {
		boolean isDBE = rm.isDoubleBufferingEnabled();
		int bdx = blitTo.x - blitFrom.x;
		int bdy = blitTo.y - blitFrom.y;

		// Move the relevant part of the backing store.
		blitWindowGraphics(blitFrom.x, blitFrom.y, blitSize.width,
				   blitSize.height, bdx, bdy);
				
		// Prepare the rest of the view; the part that has just been
		// exposed.

		Image off = rm.getOffscreenBuffer(this,getWidth(),getHeight());

		if (!blitPaintX.isEmpty()) {
		    Rectangle r = view.getBounds().intersection(blitPaintX);
		    r.x -= view.getX();
		    r.y -= view.getY();
		    g.translate(+view.getX(), +view.getY());
		    g.setClip(r.x,r.y,r.width,r.height);
		    rm.setDoubleBufferingEnabled(false);
		    view.paint(g);
		    rm.setDoubleBufferingEnabled(isDBE);
		    g.translate(-view.getX(), -view.getY());
		    
		    // The code below is added to deal with the case when
		    // Viewport is not fully contained in the View.  In that case
		    // it is the responsibility of the Viewport to clear
		    // the region outside of the View.  We define this region,
		    // then slice it into rectangles and fill those rectangles
		    // to the Viewport's background color.
		    // ozp 03/24/2009
		    RectRegion rectRegion = new RectRegion(blitPaintX);
		    rectRegion.subtract(view.getBounds());
		    if (!rectRegion.isEmpty()) {
		    	g.setClip(this.getBounds());
		    	g.setColor(this.getBackground());
		    	Rectangle damage[] = rectRegion.getRectangles();    
		    	for (int i = 0; i < damage.length; i++) {
		    	    g.fillRect(damage[i].x, damage[i].y, damage[i].width, damage[i].height);
		    	}
		    }
		    
		}
		if (!blitPaintY.isEmpty()) {
		    Rectangle r = view.getBounds().intersection(blitPaintY);
		    r.x -= view.getX();
		    r.y -= view.getY();
		    g.translate(+view.getX(), +view.getY());
		    g.setClip(r.x,r.y,r.width,r.height);
		    rm.setDoubleBufferingEnabled(false);
		    view.paint(g);
		    rm.setDoubleBufferingEnabled(isDBE);
		    g.translate(-view.getX(), -view.getY());
		    
		    // The code below is added to deal with the case when
		    // Viewport is not fully contained in the View.  In that case
		    // it is the responsibility of the Viewport to clear
		    // the region outside of the View.  We define this region,
		    // then slice it into rectangles and fill those rectangles
		    // to the Viewport's background color.
		    // ozp 03/24/2009
		    RectRegion rectRegion = new RectRegion(blitPaintY);
		    rectRegion.subtract(view.getBounds());
		    if (!rectRegion.isEmpty()) {
		    	g.setClip(this.getBounds());
		    	g.setColor(this.getBackground());
		    	Rectangle damage[] = rectRegion.getRectangles();    
		    	for (int i = 0; i < damage.length; i++) {
		    	    g.fillRect(damage[i].x, damage[i].y, damage[i].width, damage[i].height);
		    	}
		    }
		    
		}
		retValue = true;
	    }
	}
	lastPaintPosition = getViewLocation();
	return retValue;
    }

    /**
     * Called to paint the view, usually when <code>blitPaint</code>
     * can not blit.
     *
     * @param g the <code>Graphics</code> context within which to paint
     */
    protected void paintView(Graphics g) {
	Rectangle r = g.getClipBounds();
	RepaintManager rm = RepaintManager.currentManager(this);
	boolean dblbEnable = rm.isDoubleBufferingEnabled();
	JComponent view = (JComponent) getView();
	r.x -= view.getX();
	r.y -= view.getY();
	g.translate(+view.getX(), +view.getY());
	g.setClip(r.x,r.y,r.width,r.height);
	rm.setDoubleBufferingEnabled(false);
	view.paint(g);
	if(dblbEnable)
	    rm.setDoubleBufferingEnabled(true);
	g.translate(-view.getX(), -view.getY());
    }

    /**
     * Blits the parent windows graphics from the given region offset
     * to <code>ox</code>, <code>oy</code>.
     */
    protected void blitWindowGraphics(int x, int y, int w, int h, int ox,
				    int oy) {
	//!!!! ozp
	// Switched to using Graphics object returned by this.getGraphics()
	// as oppose to going up the component tree and get heavyweight 
	// parent's graphics object.  This change is necessary to allow
	// parent lightweight parent to override getGraphics() and do 
	// something special in there.  In our case, we have lightweight
	// parent that sets up stereo view flag(left, right, both) on custom
	// stereo-capable Graphics object
	//Container parent;
	//for(parent = getParent() ; isLightweightComponent(parent) ;
	  //  parent = parent.getParent());
	//Graphics wg = parent.getGraphics();
	//Rectangle r = new Rectangle(x,y,w,h);
	//r = SwingUtilities.convertRectangle(this, r, parent);
	Graphics wg = getGraphics();
	wg.copyArea(x, y, w, h, ox, oy);
	wg.dispose();
    }

    /**
     * Returns true if the viewport is not obscured by one of its ancestors,
     * or its ancestors children and if the viewport is showing. Blitting
     * when the view isn't showing will work,
     * or rather <code>copyArea</code> will work,
     * but will not produce the expected behavior.
     */
    protected boolean canUseWindowBlitter() {
	if (!isShowing() || (!(getParent() instanceof JComponent) &&
			     !(getView() instanceof JComponent))) {
	    return false;
	}
	// Change from using components width and height and (0, 0) origin to
	// component's visible rectangle coordinates.   This is 
	// necessary for proper implementation of "viewport within viewport"
	// when inner viewport is of size of the view it manages but
	// the visible rectangle is of the size of outer viewport.
	//Rectangle clip = new Rectangle(0,0,getWidth(),getHeight());
	Rectangle visibleRect = getVisibleRect();
	Rectangle clip = new Rectangle(visibleRect.x, visibleRect.y, visibleRect.width, visibleRect.height);
	Rectangle oldClip = new Rectangle();
	Rectangle tmp2;
	Rectangle b;
	Container parent;
	Component lastParent = null;
		
	for(parent = this; parent != null && isLightweightComponent(parent); parent = parent.getParent()) {
	    b = parent.getBounds();

	    oldClip.setBounds(clip);
	    SwingUtilities.computeIntersection(0, 0, b.width, b.height, clip);
	    if(!clip.equals(oldClip))
		return false;

	    if(lastParent != null && parent instanceof JComponent &&
	       !((JComponent)parent).isOptimizedDrawingEnabled()) {
		Component comps[] = parent.getComponents();
		int index = 0;

		for(int i = comps.length - 1 ;i >= 0; i--) {
		    if(comps[i] == lastParent) {
			index = i - 1;
			break;
		    }
		}

		while(index >= 0) {
		    tmp2 = comps[index].getBounds();
					
		    if(tmp2.intersects(clip))
			return false;
		    index--;
		}
	    }
	    clip.x += b.x;
	    clip.y += b.y;
	    lastParent = parent;
	}
	if (parent == null) {
	    // No Window parent.
	    return false;
	}
	return true;
    }

}

