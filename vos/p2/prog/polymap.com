$!****************************************************************************
$!
$! Build proc for MIPL module polymap
$! VPACK Version 1.9, Tuesday, January 15, 2013, 17:26:01
$!
$! Execute by entering:		$ @polymap
$!
$! The primary option controls how much is to be built.  It must be in
$! the first parameter.  Only the capitalized letters below are necessary.
$!
$! Primary options are:
$!   COMPile     Compile the program modules
$!   ALL         Build a private version, and unpack the PDF and DOC files.
$!   STD         Build a private version, and unpack the PDF file(s).
$!   SYStem      Build the system version with the CLEAN option, and
$!               unpack the PDF and DOC files.
$!   CLEAN       Clean (delete/purge) parts of the code, see secondary options
$!   UNPACK      All files are created.
$!   REPACK      Only the repack file is created.
$!   SOURCE      Only the source files are created.
$!   SORC        Only the source files are created.
$!               (This parameter is left in for backward compatibility).
$!   PDF         Only the PDF file is created.
$!   TEST        Only the test files are created.
$!   IMAKE       Only the IMAKE file (used with the VIMAKE program) is created.
$!
$!   The default is to use the STD parameter if none is provided.
$!
$!****************************************************************************
$!
$! The secondary options modify how the primary option is performed.
$! Note that secondary options apply to particular primary options,
$! listed below.  If more than one secondary is desired, separate them by
$! commas so the entire list is in a single parameter.
$!
$! Secondary options are:
$! COMPile,ALL:
$!   DEBug      Compile for debug               (/debug/noopt)
$!   PROfile    Compile for PCA                 (/debug)
$!   LISt       Generate a list file            (/list)
$!   LISTALL    Generate a full list            (/show=all)   (implies LIST)
$! CLEAN:
$!   OBJ        Delete object and list files, and purge executable (default)
$!   SRC        Delete source and make files
$!
$!****************************************************************************
$!
$ write sys$output "*** module polymap ***"
$!
$ Create_Source = ""
$ Create_Repack =""
$ Create_PDF = ""
$ Create_Test = ""
$ Create_Imake = ""
$ Do_Make = ""
$!
$! Parse the primary option, which must be in p1.
$ primary = f$edit(p1,"UPCASE,TRIM")
$ if (primary.eqs."") then primary = " "
$ secondary = f$edit(p2,"UPCASE,TRIM")
$!
$ if primary .eqs. "UNPACK" then gosub Set_Unpack_Options
$ if (f$locate("COMP", primary) .eqs. 0) then gosub Set_Exe_Options
$ if (f$locate("ALL", primary) .eqs. 0) then gosub Set_All_Options
$ if (f$locate("STD", primary) .eqs. 0) then gosub Set_Default_Options
$ if (f$locate("SYS", primary) .eqs. 0) then gosub Set_Sys_Options
$ if primary .eqs. " " then gosub Set_Default_Options
$ if primary .eqs. "REPACK" then Create_Repack = "Y"
$ if primary .eqs. "SORC" .or. primary .eqs. "SOURCE" then Create_Source = "Y"
$ if primary .eqs. "PDF" then Create_PDF = "Y"
$ if primary .eqs. "TEST" then Create_Test = "Y"
$ if primary .eqs. "IMAKE" then Create_Imake = "Y"
$ if (f$locate("CLEAN", primary) .eqs. 0) then Do_Make = "Y"
$!
$ if (Create_Source .or. Create_Repack .or. Create_PDF .or. Create_Test .or -
        Create_Imake .or. Do_Make) -
        then goto Parameter_Okay
$ write sys$output "Invalid argument given to polymap.com file -- ", primary
$ write sys$output "For a list of valid arguments, please see the header of"
$ write sys$output "of this .com file."
$ exit
$!
$Parameter_Okay:
$ if Create_Repack then gosub Repack_File
$ if Create_Source then gosub Source_File
$ if Create_PDF then gosub PDF_File
$ if Create_Test then gosub Test_File
$ if Create_Imake then gosub Imake_File
$ if Do_Make then gosub Run_Make_File
$ exit
$!
$ Set_Unpack_Options:
$   Create_Repack = "Y"
$   Create_Source = "Y"
$   Create_PDF = "Y"
$   Create_Test = "Y"
$   Create_Imake = "Y"
$ Return
$!
$ Set_EXE_Options:
$   Create_Source = "Y"
$   Create_Imake = "Y"
$   Do_Make = "Y"
$ Return
$!
$ Set_Default_Options:
$   Create_Source = "Y"
$   Create_Imake = "Y"
$   Do_Make = "Y"
$   Create_PDF = "Y"
$ Return
$!
$ Set_All_Options:
$   Create_Source = "Y"
$   Create_Imake = "Y"
$   Do_Make = "Y"
$   Create_PDF = "Y"
$ Return
$!
$ Set_Sys_Options:
$   Create_Source = "Y"
$   Create_Imake = "Y"
$   Create_PDF = "Y"
$   Do_Make = "Y"
$ Return
$!
$Run_Make_File:
$   if F$SEARCH("polymap.imake") .nes. ""
$   then
$      vimake polymap
$      purge polymap.bld
$   else
$      if F$SEARCH("polymap.bld") .eqs. ""
$      then
$         gosub Imake_File
$         vimake polymap
$      else
$      endif
$   endif
$   if (primary .eqs. " ")
$   then
$      @polymap.bld "STD"
$   else
$      @polymap.bld "''primary'" "''secondary'"
$   endif
$ Return
$!#############################################################################
$Repack_File:
$ create polymap.repack
$ DECK/DOLLARS="$ VOKAGLEVE"
$ vpack polymap.com -mixed -
	-s polymap.f -
	-p polymap.pdf -
	-i polymap.imake -
	-t tstpolymap.pdf
$ Exit
$ VOKAGLEVE
$ Return
$!#############################################################################
$Source_File:
$ create polymap.f
$ DECK/DOLLARS="$ VOKAGLEVE"
C  IBIS ROUTINE POLYMAP
C
C  POLYMAP IS USED TO CONVERT POINT OR POLYGON FILES FROM ONE MAP
C  PROJECTION TO ANOTHER.  THE FILE TO BE CONVERTED MUST BE IN THE STAND
C  IBIS POLYGON FORMAT.  THE CODE BELOW IS STRUCTURED FOR EASY
C  ADDITION OF NEW MAP PROJECTIONS.
C
C  USER PARAMETERS:
C
C  UTM -     SPECIFIES THAT THE CONVERSION IS FROM LAT-LONG TO UTM.  THE
C            FIRST POINT TO BE CONVERTED DETERMINES THE UTM ZONE, WHICH
C            ED OUT, AND THEN ALL POINTS ARE REFERENCED TO THAT ZONE EVE
C            THEY WOULD ORDINARILLY FALL IN ANOTHER ZONE.  THIS IS DONE
C            PROVIDE A SINGLE MAP PROJECTION FOR THE ENTIRE DATA SET.
C            SPECIFIES THAT THE CONVERSION IS FROM LAT-LONG TO UTM.
C            THE FIRST POINT TO BE CONVERTED DETERMINES THE UTM
C            ZONE.
C  IF INVE   SPECIFIES THAT THE CONVERSION IS FROM UTM TO LAT-LONG.  THE
C  IS        USER MUST SPECIFY THE UTM ZOME IN WHICH THE FILE FALLS.
C  SPECIFIED ALL POINTS WILL BE REFERENCED TO THAT ZONE EVEN THOUGH
C  ON UTM    THEY WOULD ORDINARILLY FALL IN ANOTHER ZONE.  THIS IS DONE
C            PROVIDE A SINGLE MAP PROJECTION FOR THE ENTIRE DATA SET.
C  LAMB,L,U - SPECIFIES THAT THE CONVERSION IS FROM LAT-LONG TO LAMBERT
C            CONFORMAL CONIC WITH TWO STANDARD PARALLELS L,U STATED IN D
C            WITH A DECIMAL POINT.  THE DEFAULT L,U IS 33.,45.
C  ALBE,L,U - SPECIFIES THAT THE CONVERSION IS FROM LAT-LONG TO ALBERS
C            EQUAL AREA WITH TWO STANDARD PARALLELS L,U STATED IN DEGREE
C            WITH A DECIMAL POINT.  THE DEFAULT L,U IS 33.,45.
C  ALB2,L,U - SPECIFIES THAT THE CONVERSION IS FROM LAT-LONG TO ALBERS
C            EQUAL AREA WITH TWO STANDARD PARALLELS AND AN EARTH SPHEROI
C            WITH MAJOR AND MINOR AXES STATED BELOW.
C  LANDSAT-  PERFORMS THE SAME CORRECTIONS AS PROGRAM ERTMGEOM.  THIS
C            REQUIRES KWDS LLINE, LSAMP, LATI, SENS, BAND.
C  ZONE,Z -  THE INTEGER Z ENFORCES A PARTICULAR UTM ZONE
C  INVE-     SPECIFIES THAT THE INVERSE MAP PROJECTION IS USED, IF
C            AVAILABLE.
C  INCO,C1,...,C6 - THIS SPECIFIES AN INPUT CONVERSION X=X*C1+Y*C2+C3,
C            Y=X*C4+Y*C5+C6.  THE C1,...,C6 CAN BE INTEGER, FLOATING, OR
C            DOUBLE PRECISION, BUT IF ANY ARE DOUBLE, ALL MUST BE DOUBLE
C  OUTC,D1,...,D6 - SAME AS INCO BUT APPLIED TO THE OUTPUT OF THE MAP
C            TRANSFORMATION.
C  SPHE      SPHEREOID PARAMETERS
C            1  = CLARK 1866 ( DEFAULT )
C            2  = CLARK 1880
C            3  = BESSEL
C            4  = MODIFIED MERCURY 1968
C            5  = INTERNATIONAL 1909
C            6  = WORLD GEODETIC SYSTEM 1972
C            7  = NEW INTERNATIONAL 1967
C            8  = EVEREST
C            9  = WORLD GEODETIC SYSTEM 1966
C            10 = GEODETIC REFERENCE SYSTEM 1980
C
C
C********************************************************************
C
C            UPDATE HISTORY
C
C            MODIFIED 4/27/84  BAM TO DO UTM TO LAT-LONG
C             SUBROUTINE TMINV HAS BEEN ADDED
C             VARIOUS SPHEROIDS ADDED
C
C            MODIFIED    LMB  ADDED NOPRINT PARAMETER
C
C            MODIFIED    KFE  APRIL 1986  
C				PUT IN CALLS TO GRAPHICS I/O SUBROUTINES
C
C            MODIFIED    EJB  SEPT 1987
C                               ADDED SPHEROIDS #6-10

c
c            ported for UNIX bam 12/95
c
c  10-Jan-2013  -lwk-  fixed CHARACTER continuation line for new compiler flag on Solaris
C
C
      INCLUDE 'VICMAIN_FOR'
      SUBROUTINE MAIN44
      IMPLICIT INTEGER(A-Z)
      LOGICAL noprint,XVPTST
      REAL*4 IGNOAR(2),INCOAR(6),OUTCAR(6),STPAR(2),INSIAR(2)
      REAL*8 DSIN,DLOG,DBLE,DABS,DTAN,DLINES(1)
      REAL*8 LAMSP1,LAMSP2,LAMN,LAMF,DT1,DT2,DEGRAD,L,S,XIGNOR,YIGNOR
      REAL*8 LOUT,SOUT
      REAL*8 ALBSP1,ALBSP2,ALBN,ALBC,ALBC2,ALB4N
      REAL*8 DCON(12),A2A,A2B,CMER,A2C2,A2E2,A2ES,A2N,A2X1,A2X2
      REAL*8 DSER,DTRIG,A2B1,A2B2
      REAL*4 CMERS
      REAL*4 LINES,VBAND,VPROF,BNDOFF,RLAT

      COMMON /COM1/LINES(5000),VBAND(5000),VPROF(5000)

      DIMENSION BNDOFF(11)
      EQUIVALENCE (LINES(1),DLINES(1))
      DATA XIGNOR,YIGNOR/2*0.D0/
      DATA DCON/1.D0,3*0.D0,1.D0,0.D0,1.D0,3*0.D0,1.D0,0.D0/
      DATA LAMSP1,LAMSP2/33.D0,45.D0/
      DATA ALBSP1,ALBSP2/33.D0,45.D0/
      DATA A2A,A2B/6378160.D0,6356775.D0/,CMER/180.D0/
      DATA IPATH/1/
      DOUBLE PRECISION SLAT,SLON,NORTH,EAST,A(16),B(4),UTZ,SK,THET
      REAL A9
      REAL	COORD1, COORD2, EXTRA(40)
      LOGICAL	ZERO, EOF
      CHARACTER*60  STRING
      LOGICAL FIXA9, INVERS, SOUTHFLAG
      DATA FIXA9/.FALSE./,BNDOFF/11*0./

      integer rdgr, wrgr, clgr, putgr, getgr

C
C
C
      DSER(S)=1.D0+2.D0*S/3.D0+3.D0*S*S/5.D0+4.D0*S*S*S/7.D0
      DTRIG(S)=(A2A*DCOS(S))**2/(1.D0-A2E2*DSIN(S)**2)
C
C  INITIALIZE, GET PARAMETERS, OPEN FILES.
C
      DEGRAD = 3.1415926536D0/180.D0
      CALL XVPARM('ZONE',ZONE,NZONE,ZONEDF,' ')
      CALL XVPARM('INCON',INCOAR,NINCO,INCODF,' ')
      CALL XVPARM('OUTCON',OUTCAR,NOUTC,OUTCDF,' ')
      CALL XVPARM('CMER',CMERS,NCMER,CMERDF,' ')
      CALL XVPARM('SKIP',SKIP,NSKIP,SKIPDF,' ')
      CALL XVPARM('IGNORE',IGNOAR,NIGNO,IGNODF,' ')
      CALL XVPARM('INSI',INSIAR,NINSI,INSIDF,' ')
      CALL XVPARM('SENS',NSENS,NNSENS,SENSDF,' ')
      CALL XVPARM('LATI',RLAT,NRLAT,LATIDF,' ')
      CALL XVPARM('BAND',BNDX,NBAND,BANDDF,' ')
      CALL XVPARM('STPAR',STPAR,NSTPAR,STPADF,' ')
      CALL XVPARM('PATH',IPATH,NPATH,PATHDF,' ')
      CALL XVPARM('SPHEROID',ISPHER,NSPHE,SPHEDF,' ')
      NOPRINT = XVPTST('NOPRINT')
      XIGNOR = DBLE(IGNOAR(1))
      YIGNOR = DBLE(IGNOAR(2))
      INVERS = XVPTST('INVERSE')

      IF (INCODF.EQ.1) GO TO 5

      IF (MOD(NINCO,6).NE.0) GO TO 401

      DO 4 I=1,6
         DCON(I) = DBLE(INCOAR(I))
C         IF (NINCO.NE.12) GO TO 4
C         CALL MVL(INCOAR(I*2-1),DCON(I),8)
 4    CONTINUE


 5    CONTINUE
      IF (OUTCDF.EQ.1) GO TO 7

      IF (MOD(NOUTC,6).NE.0) GO TO 401

      DO 6 I=1,6
         DCON(6+I) = DBLE(OUTCAR(I))
C         IF (NOUTC.NE.12) GO TO 6
C         CALL MVL(OUTCAR(I*2-1),DCON(6+I),8)
 6    CONTINUE


 7    CONTINUE
      CMER = DBLE(CMERS)

C
C  INITIALIZATION FOR EACH SPECIFIC TRANSFORMATION.
C

      IF(XVPTST('LAMBERT')) IXTRAN = 1
      IF(XVPTST('UTM'))     IXTRAN = 2
      IF(XVPTST('LANDSAT')) IXTRAN = 3
      IF(XVPTST('ALBERS'))  IXTRAN = 4
      IF(XVPTST('ALBERS2')) IXTRAN = 5
      IF(XVPTST('SOM'))     IXTRAN = 6
      GO TO (201,202,203,204,205,206,207,208),IXTRAN
C
C---- INITIALIZE LAMBERT
C
 201  LAMSP1 = DBLE(STPAR(1))
      LAMSP2 = DBLE(STPAR(2))

! to appease I&T 
      if (lamsp1.lt.-180.D0.or.lamsp1.gt.360.D0.or.
     -    lamsp2.lt.-180.D0.or.lamsp2.gt.360.D0) then
          call xvmessage( 'Invalid Lambert Value.', ' ')
          call xvmessage( 'Please correct and resubmit.', ' ')
          return
      end if

      LAMSP1 = (90.D0-LAMSP1)*DEGRAD
      LAMSP2 = (90.D0-LAMSP2)*DEGRAD
      DT1 = DLOG(DSIN(LAMSP1))-DLOG(DSIN(LAMSP2))
      DT2 = DLOG(DTAN(LAMSP1/2.D0))-DLOG(DTAN(LAMSP2/2.D0))
      LAMN = DT1/DT2
      LAMF = DSIN(LAMSP1)/(LAMN*DTAN(LAMSP1/2.D0)**LAMN)
      GO TO 100

C
C  EXTRACTED FROM GENERAL ROUTINE UTMGRID COURTESY OF THE USGS
C  THIS CODE IS FOR BOTH UTM TO LAT-LONG AND LAT-LONG TO UTM
C  UTM ZONE FIXED BY FIRST POINT IN DATA SET OR PARAMETER
C
 202  A(5) = 5.0D5
      A(6) = 0.0D0
      A(7) = 0.0D0
      A(8) = 0.9996D0
C
      IF (ZONE .LT. 0.0) THEN
	SOUTHFLAG = .TRUE.
      ELSE
	SOUTHFLAG = .FALSE.
      ENDIF

C
C     NOW THE CORRECT SPHEROID PARAMETER
C
C-----CLARK 1866
C
      IF(ISPHER .EQ. 1) THEN
        A(15) = 6378206.4D0
        B(1)  = 6356583.8D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' CLARK 1866',' ')
C     
C-----CLARK 1880
C
      ELSEIF(ISPHER .EQ. 2) THEN
        A(15) = 6378249.1450D0
        B(1)  = 6356514.86955D0
        IF (.NOT. NOPRINT)  CALL XVMESSAGE(' CLARK 1880',' ')
C     
C-----BESSEL
C 
      ELSEIF(ISPHER .EQ. 3) THEN
        A(15) = 6377397.1550D0
        B(1)  = 6356078.96284D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' BESSEL',' ')
C      
C-----MODIFIED MERCURY 1968
C 
      ELSEIF(ISPHER .EQ. 4) THEN
        A(15) = 6378150.0D0
        B(1)  = 6356768.337D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' MODIFIED MERCURY 1968',' ')
C      
C-----INTERNATIONAL
C 
      ELSEIF(ISPHER .EQ. 5) THEN
        A(15) = 6378388.0D0
        B(1)  = 6356911.94613D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' INTERNATIONAL',' ')
C
C-----WORLD GEODETIC SYSTEM 1972
C
      ELSEIF(ISPHER .EQ. 6) THEN
        A(15) = 6378135.0D0
        B(1)  = 6356750.519915D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' WORLD GEOD. SYS. 1972',' ')
C
C-----NEW INTERNATIONAL 1967
C
      ELSEIF(ISPHER .EQ. 7) THEN
        A(15) = 6378157.5D0
        B(1)  = 6356772.2D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' NEW INTERNATNL. 1967',' ')
C
C-----EVEREST
C
      ELSEIF(ISPHER .EQ. 8) THEN
        A(15) = 6377276.3452D0
        B(1)  = 6356075.4133D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' EVEREST',' ')
C
C-----WORLD GEODETIC SYSTEM 1966
C
      ELSEIF(ISPHER .EQ. 9) THEN
        A(15) = 6378145.0D0
        B(1)  = 6356759.769356D0
        IF (.NOT. NOPRINT) CALL XVMESSAGE(' WORLD GEOD. SYS. 1966',' ')
C
C-----GEODETIC REFERENCE SYSTEM 1980
C
      ELSEIF(ISPHER .EQ. 10) THEN
        A(15) = 6378137.0D0
        B(1)  = 6356752.31414D0
        IF(.NOT. NOPRINT) CALL XVMESSAGE(' GEOD. REF. SYS. 1980',' ')
C
C-----INVALID CHOICE FOR PARAMETER ISPHER
C
      ELSE
        CALL XVMESSAGE(' INVALID CHOICE FOR PARAM. ISPHER',' ')
        CALL XVMESSAGE(' 1 .LE.  ISPHER .LE. 10',' ')
        STOP
      ENDIF                
C
C
 2006 CONTINUE
      A(16) = ((A(15)-B(1))/A(15))*((A(15)+B(1))/A(15))
C
C     COMPUTE COEFFICIENTS FOR BOTH FORWARD AND INVERSE CONVERSIONS
C
      CALL TMCOF(A)
      GO TO 100
C
C---- INITIALIZE LANDSAT
C
 203  CONTINUE
      IF(INSIDF.EQ.1.OR.SENSDF.EQ.1.OR.LATIDF.EQ.1.OR.BANDDF.EQ.1)
     *                  GO TO 401
      LLINE = INSIAR(1)    ! to appease I&T bam 7/96
      LSAMP = INSIAR(2)
      if ( lline .lt. 0 .or. lsamp. lt. 0 ) then
          call xvmessage( 'Invalid INSI value.', ' ')
          call xvmessage( 'Please correct and resubmit.', ' ')
          return
      end if

      LS200 = LSAMP+200
      IF (BNDX.EQ.0) BNDX = 11
      CALL SYSCOR(VBAND,VPROF,LLINE,LSAMP,LS200,NSENS,RLAT,BNDOFF)
      CALL ADJUST(VBAND,LLINE,0,LINES,BNDOFF(BNDX),INVERS)
      CALL ADJUST(VPROF,LS200,1,LINES,0.,INVERS)
      GO TO 100
C
C---- INITIALIZE ALBERS
C
 204  ALBSP1 = DBLE(STPAR(1))
      ALBSP2 = DBLE(STPAR(2))
      ALBSP1 = (90.D0-ALBSP1)*DEGRAD
      ALBSP2 = (90.D0-ALBSP2)*DEGRAD
      ALBN = (DCOS(ALBSP1)+DCOS(ALBSP2))/2.D0
      DT1 = DSIN(ALBSP1/2.D0)*DSIN(ALBSP2/2.D0)/ALBN
      ALBC = 4.0D0*DT1*DT1
      ALBC2 = ALBC*ALBC
      ALB4N = 4.0D0/ALBN
      GO TO 100
C
C---- INITIALIZE ALBERS2
C
 205  ALBSP1 = DBLE(STPAR(1))*DEGRAD
      ALBSP2 = DBLE(STPAR(2))*DEGRAD
      A2E2 = (A2A*A2A-A2B*A2B)/(A2A*A2A)
      A2ES = DSER(A2E2)
      A2C2 = A2A*A2A*(1.D0-A2E2)*A2ES
      A2B1 = DSIN(ALBSP1)*DSER(A2E2*DSIN(ALBSP1)**2)/A2ES
      A2B2 = DSIN(ALBSP2)*DSER(A2E2*DSIN(ALBSP2)**2)/A2ES
      A2N = (DTRIG(ALBSP1)-DTRIG(ALBSP2))/(2.D0*A2C2*(A2B2-A2B1))
      A2X1 = 2.D0*A2C2/A2N
      A2X2 = (A2A*A2A*DCOS(ALBSP1)**2)/(A2N*A2N*(1.D0-A2E2*DSIN(ALBSP1)
     .**2))
      GO TO 100
C
C---- SPACE OBLIQUE MERCATOR PROJECTION. INITIALIZE.
C
 206  CONTINUE
      IF (.NOT.NOPRINT)CALL XVMESSAGE(' SPACE OBLIQUE MERCATOR',' ')
      IF(INVERS .AND. .NOT. NOPRINT) 
     *			CALL XVMESSAGE(' INVERSE TRANSFORM',' ')
      CALL SOM(L,S,LOUT,SOUT,IPATH,INVERS,1)
      GO TO 100
C
C     THIS IS A PLACE FOR A NEW CONVERSIONS
C
 207  CONTINUE
 208  CONTINUE
C
C
 100  CONTINUE
C
C  APPLY TRANSFORMATION TO DATA SET
C
C
C  OPEN THE INPUT AND OUTPUT GRAPHICS FILES
	 status = rdgr (1, 1, 2+SKIP)
         if (status.ne.1) call signalgr(1,status,1)
	 status = wrgr (1, 2, 2+SKIP)
         if (status.ne.1) call signalgr(1,status,1)
C
	PRINTCOUNT = 0
	IF (.NOT. NOPRINT) THEN
	    WRITE (STRING, '(A)' ) 
     *	'        INPUT COORDINATES           OUTPUT COORDINATES'
	    CALL XVMESSAGE (STRING,' ')
	ENDIF
C
C	BEGINNING OF LOOP THROUGH GRAPHICS FILE
 101  CONTINUE
	status = getgr (1, ZERO, EOF, COORD1, COORD2, EXTRA)
        if (status.ne.1) call signalgr(1,status,1)
	IF (EOF) GOTO 106
	L = DBLE(COORD1)
	S = DBLE(COORD2)
	IF (DABS(L-XIGNOR)+DABS(S-YIGNOR).LE.1.D-6) GO TO 107
C
	DT1 = DCON(1)*L+DCON(2)*S+DCON(3)
	S = DCON(4)*L+DCON(5)*S+DCON(6)
	L = DT1
C
C     GO OFF AND CONVERT DATA
C
      GO TO (301,302,303,304,305,306,307,308),IXTRAN
C
 301  IF (INVERS) GO TO 3011
      IF (L.LT.-90.D0.OR.L.GT.90.D0) GO TO 104
      DT1 = LAMF*DTAN((90.D0-L)*DEGRAD/2.D0)**LAMN
      DT2 = LAMN*(S-CMER)*DEGRAD
      L = DT1*DCOS(DT2)
      S = DT1*DSIN(DT2)
      GO TO 105
 3011  DT2 = DATAN2(S,L)
      DT1 = DSQRT(L*L+S*S)
      S = DT2/(LAMN*DEGRAD)+CMER
      L = 90.D0-DATAN(((DT1/LAMF)**(1.D0/LAMN)))*2.D0/DEGRAD
      GO TO 105
C
C     LATITUDE - LONGITUDE AND UTM CONVERSIONS
C
 302  CONTINUE
      IF ( INVERS ) GO TO 3025
C
C     LAT - LONG TO UTM
C
      SLAT = L*3600.0D0
      SLON = S*3600.0D0
      IF (FIXA9) GO TO 3023
      FIXA9 = .TRUE.
      IDLON = S
      IZONE = 30-(IDLON/6)
      IF (IDLON.LT.0) IZONE = IDLON/6+31
      IF (ZONEDF.EQ.0) IZONE = ZONE
      IF (.NOT. NOPRINT) CALL PRNT(4,1,IZONE,' UTM ZONE.')
      IF (IABS(IZONE).LE.30) THEN
        UTZ = 30.0D0-IABS(IZONE)
        A(9) = ((UTZ*6.0D0)+3.0D0)*3600.0D0
      ELSE
        UTZ = IABS(IZONE)-30.0D0
        A(9) = ((UTZ*6.0D0)-3.0D0)*(-3600.0D0)
      ENDIF
      A9 = A(9)/3600.0
      IF (.NOT. NOPRINT)  CALL PRNT(7,1,A9,' CENT MERID.')
 3023 CALL TMFWD(SLAT,SLON,NORTH,EAST,A,IERR,SK,THET)
      IF (IERR.EQ.1) GO TO 104
      IF (SOUTHFLAG) THEN
        L = 1.0D7 + NORTH
      ELSE
        L = NORTH
      ENDIF
      S = EAST
      GO TO 105
C
C     UTM TO LAT - LONG
C
 3025 CONTINUE
      IF (SOUTHFLAG) THEN
        NORTH = L - 1.0D7
      ELSE
        NORTH = L
      ENDIF
      EAST  = S
C
C     CHECK FOR THE FIRST TIME IN
C
      IF (FIXA9) GO TO 3028
      FIXA9 = .TRUE.
      IZONE = ZONE
      IF ( IZONE .EQ. 0 ) GO TO 401
      IF (.NOT. NOPRINT)  CALL PRNT(4,1,IZONE,' UTM ZONE.')
C
C     COMPUTE THE CENTRAL MERIDIAN AS A FUNCTION OF ZONE
C
      UTZ = 30.0D0-IABS(IZONE)
      A(9) = ((UTZ*6.0D0)+3.0D0)*3600.0D0
      A9 = A(9)/3600.0
      IF (.NOT. NOPRINT) CALL PRNT(7,1,A9,' CENT MERID.')
C
C     NOW COMPUTE LATITUDE AND LONGITUDE
C
 3028 CONTINUE
      CALL TMINV(NORTH,EAST,SLAT,SLON,A,IERR,SK,THET)
      IF (IERR.EQ.1) GO TO 104
      L = SLAT / 3600.D0
      S = SLON / 3600.D0
      GO TO 105
C
 303  IL = INT(SNGL(L))
      IS = INT(SNGL(S))
      IF (INVERS) IS = INT(SNGL(S)+VBAND(IL))
      IF (IL.LT.1.OR.IL.GT.LLINE) GO TO 105
      IF (IS.LT.1.OR.IS.GT.LSAMP) GO TO 105
      S = S+DBLE(VBAND(IL)+VPROF(IS))
      GO TO 105
C
 304  IF (L.LT.-90.D0.OR.L.GT.90.D0) GO TO 104
      DT1 = DSIN((90.D0-L)*DEGRAD*0.5D0)
      DT1 = DSQRT(ALBC2+ALB4N*DT1*DT1)
      DT2 = ALBN*S*DEGRAD
      L = DT1*DCOS(DT2)
      S = DT1*DSIN(DT2)
      GO TO 105
C
 305  IF (L.LT.-90.D0.OR.L.GT.90.D0) GO TO 104
      DT1 = DSIN(L*DEGRAD)*DSER(A2E2*DSIN(L*DEGRAD)**2)/A2ES
      DT1 = DSQRT(A2X1*(A2B1-DT1)+A2X2)
      DT2 = A2N*((CMER-S)*DEGRAD)
      L = DT1*DCOS(DT2)
      S = DT1*DSIN(DT2)
      GO TO 105
C
C---- SPACE OBLIQUE MERCATOR COMPUTATIONS.
C
 306  CONTINUE
      CALL SOM(L,S,LOUT,SOUT,IPATH,INVERS,2)
      L=LOUT
      S=SOUT
      GO TO 105
C
C     PLACE LEFT FOR TWO MORE OPTIONS
C
 307  CONTINUE
      GO TO 105
 308  CONTINUE
      GO TO 105
C
C     WE GET HERE IF AN ERROR WAS ENCOUNTERED IN USGS SUBROUTINES
C
 104  CONTINUE
      CALL PRNT(8,2,L,' BAD PT.')
      GO TO 106
C
C     GOOD POINT - NORMAL STATUS
C
C
 105  DT1 = DCON(7)*L+DCON(8)*S+DCON(9)
      S = DCON(10)*L+DCON(11)*S+DCON(12)
      L = DT1
C
 107  CONTINUE
	IF (.NOT. NOPRINT .AND. PRINTCOUNT .LT. 5) THEN
	    WRITE (STRING, '(F12.3,1X,F12.3,4X,F12.3,1X,F12.3)' )
     *				 COORD1, COORD2, L,S
	    CALL XVMESSAGE (STRING,' ')
	    PRINTCOUNT = PRINTCOUNT + 1
	ENDIF
	COORD1 = SNGL(L)
	COORD2 = SNGL(S)
	status = putgr (2, COORD1, COORD2, EXTRA)
        if (status.ne.1) call signalgr(1,status,1)
C
      GOTO 101
C	END OF LOOP THROUGH GRAPHICS FILE
C
 106  CONTINUE
       status = clgr (1)
       if (status.ne.1) call signalgr(1,status,1)
       status = clgr (2)
       if (status.ne.1) call signalgr(1,status,1)
C
      RETURN
 401  CALL XVMESSAGE(' PARAM ERR',' ')
      RETURN
      END
C**********************************************************
      SUBROUTINE ADJUST(RPAR,M,NORM,WORK,BND,INVERS)
C
      IMPLICIT INTEGER(A-Q),REAL*4(R-Z)
      REAL*4 FLOAT,BND
      LOGICAL INVERS
      DIMENSION RPAR(M),WORK(M)
C
      R1 = RPAR(1)
      DO 5 I=1,M
 5    RMIN = AMIN1(RPAR(I),RMIN)
      DO 6 I=1,M
      IF (NORM.NE.1) WORK(I) = RPAR(I)-RMIN+BND
      IF (NORM.EQ.1) WORK(I) = RPAR(I)-R1
 6    CONTINUE
      IF (WORK(M-200).GT.190) CALL MABEND(15)
 7    DO 10 I=1,M
      X = WORK(I)
      IF (.NOT.INVERS) GO TO 10
      IF (NORM.NE.1) GO TO 2
      IX = I-INT(X)
      IF (I.EQ.IX) GO TO 2
      IF (IX.GT.M) GO TO 2
      W = WORK(IX)
      XY = FLOAT(I-IX)
      X = XY-((XY-W)*XY)/(XY+X-W)
 2    X = -X
 10   RPAR(I) = X
      RETURN
      END
C**********************************************************
      SUBROUTINE INVRS(X,Y,TLAT,TLON,DLAT,DLON)
C
C     THIS SUBROUTINE COMPUTES TRANSFORMED LAT/LON AND GEODETIC
C     LAT/LON GIVEN X-Y
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON / SER/ A,B,A2,A4,C1,C3,PI
      COMMON / NORM/ Q,T,U,W,E2,P21,SA,CA
      COMMON /PRM/ XJ,S,DEGRAD
C
C     BEGIN INVERSE COMPUTATION WITH APPROXIMATION FOR TLON. SOLVE
C     FOR TRANSFORMED LONG.
C
      TLON= X/(A*B)
      CONV=1.D-9
      INUMB=0
  813 SAV=TLON
      SD=DSIN(TLON)
      SDSQ=SD*SD
      S=P21*SA*DCOS(TLON)*DSQRT((1.D0+T*SDSQ)/((1.D0+W*SDSQ)*(1.D0+Q*SDS
     *Q)))
      BLON=(X/A)+(Y/A)*S/XJ-A2*DSIN(2.D0*TLON)-A4*DSIN(4.D0*TLON)-(S/XJ)
     **(C1*DSIN(TLON)+C3*DSIN(3.D0*TLON))
      TLON=BLON/B
      DIF=TLON-SAV
      IF(DABS(DIF).LT.CONV) GO TO 814
      INUMB=INUMB+1
      IF(INUMB.EQ.50) GO TO 814
      GO TO 813
C
C     COMPUTE TRANSFORMED LAT.
C
  814 CONTINUE
      ST=DSIN(TLON)
      DEFAC=DEXP(DSQRT(1.D0+S*S/XJ/XJ)*(Y/A-C1*ST-C3*DSIN(3.D0*TLON)))
      ACTAN=DATAN(DEFAC)
      TLAT=2.0D0*(ACTAN-(PI/4.0D0))
C
C     COMPUTE GEODETIC LONGITUDE
C
      DD=ST*ST
      IF(DABS(DCOS(TLON)).LT.1.D-7) TLON=TLON-1.D-7
      BIGK=DSIN(TLAT)
      BIGK2=BIGK*BIGK
      XLAMT=DATAN(((1.D0-BIGK2/(1.D0-E2))*DTAN(TLON)*CA-BIGK*SA*DSQRT((1
     *.D0+Q*DD)*(1.D0-BIGK2)-BIGK2*U)/DCOS(TLON))/(1.D0-BIGK2*(1.D0+U)))
C
C     CORRECT INVERSE  QUADRANT
C
      IF(XLAMT.GE.0.D0) SL=1.D0
      IF(XLAMT.LT.0.D0) SL=-1.D0
      IF(DCOS(TLON).GE.0.D0) SCL=1.D0
      IF(DCOS(TLON).LT.0.D0) SCL=-1.0D0
      XLAMT=XLAMT-((PI/2.D0)*(1.D0-SCL)*SL)
      DLON=XLAMT-P21*TLON
C
C     COMPUTE GEODETIC LATITUDE
C
      IF(DABS(SA) .LT.1.D-7)DLAT=DASIN(BIGK/DSQRT((1.D0-E2)*(1.D0-E2)
     *+E2*BIGK2))
      IF(DABS(SA) .LT.1.D-7)GO TO 1
      DLAT=DATAN((DTAN(TLON)*DCOS(XLAMT)-CA*DSIN(XLAMT))/((1.D0-E2)*SA))
    1 CONTINUE
C
C     CONVERT DLAT/DLON IN RADIANS TO DEGREES
C
      DLAT=DLAT*DEGRAD
      DLON=DLON*DEGRAD
      RETURN
      END
C**********************************************************
      SUBROUTINE SERA (FB,FA2,FA4,FC1,FC3,DLAM)
C
C     THIS SUBROUTINE COMPUTES THE INTEGRAL FUNCTION OF LAMBDA FOR
C     FOURIER CONSTANTS AN,B, AND CN
C     DLAM IS INTEGRAL VALUE OF LAMBDA
C
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON / NORM/ Q,T,U,W,E2,P21,SA,CA
       COMMON /PRM/ XJ,S,DEGRAD
C     CONVERT DLAM TO RADIANS
      DLAM=DLAM/DEGRAD
      SD=DSIN(DLAM)
      SDSQ=SD*SD
      S=P21*SA*DCOS(DLAM)*DSQRT((1.D0+T*SDSQ)/((1.D0+W*SDSQ)*(1.D0+Q*SDS
     *Q)))
      H=DSQRT((1.D0+Q*SDSQ)/(1.D0+W*SDSQ))*(((1.D0+W*SDSQ)/((1.D0+Q*SDSQ
     *)**2))-P21*CA)
      SQ=DSQRT(XJ*XJ+S*S)
      FB=(H*XJ-S*S)/SQ
      FA2=FB*DCOS(2.D0*DLAM)
      FA4=FB*DCOS(4.D0*DLAM)
      FC=S*(H+XJ)/SQ
      FC1=FC*DCOS(DLAM)
      FC3=FC*DCOS(3.D0*DLAM)
      RETURN
      END
C**********************************************************
      SUBROUTINE SERIES (A2,A4,B,C1,C3)
C
C     THIS SUBROUTINE COMPUTES ALL FOURIER COEFFICIENTS
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
C     COMPUTE INTEGRAL CONTRIBUTIONS FOR OTHER FOURIER CONSTANTS
C     DLAM IS THE CURRENT VALUE OF LAMBDA DOUBLE-PRIME
      DLAM=0.0D0
      CALL SERA(FB,FA2,FA4,FC1,FC3,DLAM)
      SUMA2=FA2
      SUMA4=FA4
      SUMB=FB
      SUMC1=FC1
      SUMC3=FC3
      DO 206 I=9,81,18
      DLAM=DFLOAT(I)
      CALL SERA(FB,FA2,FA4,FC1,FC3,DLAM)
      SUMA2=SUMA2+4.D0*FA2
      SUMA4=SUMA4+4.D0*FA4
      SUMB=SUMB+4.D0*FB
      SUMC1=SUMC1+4.D0*FC1
      SUMC3=SUMC3+4.D0*FC3
  206 CONTINUE
      DO 207 I=18,72,18
      DLAM=DFLOAT(I)
      CALL SERA(FB,FA2,FA4,FC1,FC3,DLAM)
      SUMA2=SUMA2+2.D0*FA2
      SUMA4=SUMA4+2.D0*FA4
      SUMB=SUMB+2.D0*FB
      SUMC1=SUMC1+2.D0*FC1
      SUMC3=SUMC3+2.D0*FC3
  207 CONTINUE
      DLAM=90.D0
      CALL SERA(FB,FA2,FA4,FC1,FC3,DLAM)
      SUMA2=SUMA2+FA2
      SUMA4=SUMA4+FA4
      SUMB=SUMB+FB
      SUMC1=SUMC1+FC1
      SUMC3=SUMC3+FC3
C
C     THESE ARE THE VALUES OF FOURIER CONSTANTS
C
      A2=SUMA2/30.D0
      A4=SUMA4/60.D0
      B=SUMB/30.D0
      C1=SUMC1/15.D0
      C3=SUMC3/45.D0
      RETURN
      END
C**********************************************************
      SUBROUTINE SOM(LIN,SIN,LOUT,SOUT,IPATH,INVERS,MODE)
C
C     PROGRAM NO. L271 PLACED ON THE LIBRARY ON SEPT 9, 1983
C     LANDSAT 4 SPACE OBLIQUE MERCATOR (SOM) PROJECTION PROGRAM NO.L271
C     1982 - MODIFIED JUNE 1983 (LANDSAT 4 CONSTANT) - JOHN P. SNYDER
C
C     THIS PROGRAM EMPLOYS THE MATHEMATICAL DEVELOPMENT FOR THE SPACE
C         OBLIQUE MERCATOR PROJECTION (COLVOCORESSES, 1974), PRESENTED
C         BY JOHN P. SNYDER, TO COMPUTE LATITUDE/LONGITUDE
C         TO X,Y-COORDINATE CONVERSIONS, THE INVERSE.
C
C     THIS IS A MODIFIED VERSION FOR LANDSAT 4 OF PROGRAM NO.J902 (SOM)
C
C     COMPUTATIONAL METHODOLOGY IS:
C         1- (1982) DEFINE THE SATELLITE ORBIT IN P1-P2-ALF-A-E2
C         2- COMPUTE THE FOURIER SERIES COEFFICIENTS USED TO
C            APPROXIMATE THE SATELLITE ORBIT
C         3-  A: FOR FORWARD COMPUTATIONS; INPUT LATITUDE/LONGITUDE
C                COORDINATES, ITERATIVELY COMPUTE TRANSFORMED
C                PHI AND LAMBDA, AND USE THE SERIES COEFFICIENTS
C                TO DETERMINE X AND Y COORDINATES.
C             B: FOR INVERSE COMPUTATIONS; INPUT SOM X AND Y COORDINATES
C                , ITERATIVELY COMPUTE TRANSFORMED PHI AND LAMBDA
C                USING THE SERIES COEFFICIENTS, AND THEN COMPUTE
C                LATITUDE AND LONGITUDE,
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 LIN,SIN,LOUT,SOUT
      COMMON / SER/ A,B,A2,A4,C1,C3,PI
      COMMON / NORM/ Q,T,U,W,E2,P21,SA,CA
      COMMON /PRM/ XJ,S,DEGRAD
      LOGICAL INVERS
      CHARACTER*4 IALF(16)
      DATA IALF/16*'    '/
C
      IF(MODE.EQ.2) GO TO 820
      PI=3.14159265D0
      DEGRAD=57.29577951D0
      WRITE(6,901)
  901 FORMAT(1H1,32X,'S P A C E   O B L I Q U E   M E R C A T O R   C O M P U T A T I O N S'//)
C     SETUP CONSTANTS FOR THE ORBIT. P2 IS SATELLITE REVOLUTION, MIN.
C     P1 IS EARTH ROTATION, MIN., BETWEEN ASCENDING NODES OF SAT. ORBIT
C     ALF IS INCLINATION OF SATELLITE ORBIT TO EARTH EQUATOR
C     COUNTERCLOCKWISE FROM EAST AT ASCENDING NODE. RADIANS.
C     A IS MAJOR SEMI-DIAMETER OF EARTH, METERS.  E2 IS SQUARE OF
C     ECCENTRICITY OF EARTH ELLIPSOID.
C     Q,T,U,W, AND XJ ARE CONVENIENT EXPRESSIONS.
C     (1982) CONSTANTS GIVEN ARE FOR LANDSAT 4.
C     (1982) COMMENT CONSTANTS ARE FOR LANDSATS 1,2, AND 3.
C     LANDSATS 1,2,3
C     P2=103.2669323D0
C     ALF= 99.092D0*(PI/180.D0)
C     LANDSAT 4  VALUES 98.8841202D0 AND 98.22D0*(PI/180.D0)
      P2=98.8841202D0
      P1=1440.D0
      ALF=98.22D0*(PI/180.D0)
      CA=DCOS(ALF)
      IF (DABS(CA).LT.1.D-9) CA=1.D-9
      SA=DSIN(ALF)
C
C     CLARKE 1866 ELLIPSOID USED HERE.  CHANGE A AND E2 FOR OTHER
C     ELLIPSOIDS.
      A=6378206.4D0
      SCALE=A
      E2=0.00676866D0
      E2C=E2*CA*CA
      E2S=E2*SA*SA
      W=((1.D0-E2C)/(1.D0-E2))**2-1.D0
      Q = E2S / (1.D0-E2)
      T = (E2S*(2.D0-E2)) / (1.D0-E2)**2
      U= E2C / (1.D0-E2)
      XJ = (1.D0-E2)**3
      WRITE (6,800) P2,P1,ALF,A,E2,W,Q,T,U,XJ
  800 FORMAT(1H0,'CONSTANTS FOR THE ORBIT .......'/(1H ,5D24.16))
      P21=P2/P1
C
C     SCALE IS NO. OF UNITS EQUAL TO 'A' IF X AND Y MAP COORDINATES
C     ARE TABULATED.
C
C
C---- COMPUTE SERIES APPROXIMATIONS PER ORBIT TYPE
C
      CALL SERIES (A2,A4,B,C1,C3)
      RETURN
  820 CONTINUE
      IF(INVERS) GO TO 810
C
C---- CONVERT GREENWICH LONGITUDE TO LONGITUDE
C     RELATIVE TO ASCENDING NODE
C     THIS CONVERSION VARIES WITH ORBIT
C
C     DLON=DLON-128.87D0+(360.D0/251.D0)*(DFLOAT(IPATH))
C     LANDSAT 4.
      DLAT=LIN
      DLON=SIN
      DLON=DLON-129.30D0+(360.D0/233.D0)*(DFLOAT(IPATH))
C
C     ITERATE TO FIND TRANSFORMED LATITUDE AND LONGITUDE
      CALL TRANSF(DLAT,DLON,TPHI,TLAM,X,Y)
      SOUT=X*SCALE/A
      LOUT=Y*SCALE/A
      RETURN
C
C---- COMPUTE INVERSE
C     CHANGE INPUT X AND Y COORDINATES TO FULL-SCALE METERS FOR INVERSE
  810 CONTINUE
      X=SIN*A/SCALE
      Y=LIN*A/SCALE
      CALL INVRS(X,Y,TLAT,TLON,DLAT,DLON)
C
C---- CONVERT LONGITUDE RELATIVE TO ASCENDING NODE TO
C     LONGITUDE RELATIVE TO GREENWICH
C     THIS CONVERSION VARIES WITH ORBIT
C
C     DLON=DLON+128.87D0-(360.D0/251.D0)*(DFLOAT(IPATH))
C     LANDSAT 4.
      DLON=DLON+129.30D0-(360.D0/233.D0)*(DFLOAT(IPATH))
      IF (DLON.GT.180.D0) DLON=DLON-360.D0
      IF (DLON.LT.-180.D0) DLON=DLON+360.D0
      LOUT=DLAT
      SOUT=DLON
      TPHI=TLAT*DEGRAD
      TLAM=TLON*DEGRAD
      RETURN
      END
C
      SUBROUTINE SYSCOR(VBAND,VPROF,NL,NS,NVPROF,NSENS,RLAT,BNDOFF)
      REAL*8 GAM,BET,F,RAD,HT,P,RH
      DIMENSION VBAND(NL),VPROF(NVPROF),BNDOFF(10)
C
C  EACH SENSOR HAS A UNIQUE NUMBER.  PLACE BAND-SKEW GEOMETRY CORRECTION
C  IN VBAND(I),I=1,...,NL.  PLACE PROFILE GEOMETRY CORRECTION IN
C  VPROF(I),I=1,...,NVPROF USING NS AS THE INPUT WIDTH.  BOTH CORRECT-
C  IONS ARE SHIFTED BY ROUTINE ADJUST TO LEFT JUSTIFY THE CORNER OF THE
C  IMAGE.  PLACE BAND OFFSETS IN BNDOFF(I), I=(BAND NUMBERS).  THESE WIL
C  NOT BE ADJUSTED.  ALL CORRECTIONS ARE IN PIXELS.
C
      DATA RAD,HT/6367.D3,912.D3/
      DATA TS1,THS1,W1,A1,B1,C1/.03230,.201498,16.5248,.384045,-.251320,
     *.095505/
      DATA TS2,THS2,W2,A2,B2,C2/.03233,.201586,17.0903,.369540,-.267250,
     *.097588/
      DATA TS3,THS3,W3,A3,B3,C3/.03233,.201586,17.0903,.369540,-.267250,
     *.097588/
C
      RL = RLAT*3.141593/180.
      GO TO (100,200,300,400),NSENS
      CALL MABEND(12)
C
C  LANDSAT 1
C
 100  PSK = -.596834*SQRT(COS(RL)**2-.02495)
      DO 101 I=1,NL
 101  VBAND(I) = ((I-1)/6)*PSK+MOD(I-1,6)/12.
      DO 102 I=1,NVPROF
      T = ((I-1.)/(NS-1.))*TS1
      CORR = ((A1*SIN(W1*T+B1)-(THS1*T/TS1-C1))/THS1)*NS
      P = (I+CORR-NS/2.)*57.79
      GAM = P/RAD
      RH = RAD/HT
      BET = DATAN2(RH*DSIN(GAM),1.D0+RH*(1.D0-DCOS(GAM)))
      F = (HT*BET)/(RAD*GAM)
      CP = (1.D0-F)*P/57.79
 102  VPROF(I) = CORR+CP
      DO 103 I=4,7
 103  BNDOFF(I) = (I-4)*112./57.79
      RETURN
C
C  LANDSAT 2
C
 200  PSK = -.596834*SQRT(COS(RL)**2-.02495)
      DO 201 I=1,NL
 201  VBAND(I) = ((I-1)/6)*PSK+MOD(I-1,6)/12.
      DO 202 I=1,NVPROF
      T = ((I-1.)/(NS-1.))*TS2
      CORR = ((A2*SIN(W2*T+B2)-(THS2*T/TS2-C2))/THS2)*NS
      P = (I+CORR-NS/2.)*57.79
      GAM = P/RAD
      RH = RAD/HT
      BET = DATAN2(RH*DSIN(GAM),1.D0+RH*(1.D0-DCOS(GAM)))
      F = (HT*BET)/(RAD*GAM)
      CP = (1.D0-F)*P/57.79
 202  VPROF(I) = CORR+CP
      DO 203 I=4,7
 203  BNDOFF(I) = (I-4)*112./57.79
      RETURN
C
C  LANDSAT 3
C
 300  PSK = -.596834*SQRT(COS(RL)**2-.02495)
      DO 301 I=1,NL
 301  VBAND(I) = ((I-1)/6)*PSK+MOD(I-1,6)/12.
      DO 302 I=1,NVPROF
      T = ((I-1.)/(NS-1.))*TS3
      CORR = ((A3*SIN(W3*T+B3)-(THS3*T/TS3-C3))/THS3)*NS
      P = (I+CORR-NS/2.)*57.79
      GAM = P/RAD
      RH = RAD/HT
      BET = DATAN2(RH*DSIN(GAM),1.D0+RH*(1.D0-DCOS(GAM)))
      F = (HT*BET)/(RAD*GAM)
      CP = (1.D0-F)*P/57.79
 302  VPROF(I) = CORR+CP
      DO 303 I=4,7
 303  BNDOFF(I) = (I-4)*112./57.79
      RETURN
C
C  TEST FUNCTION
C
 400  DO 401 I=1,NL
 401  VBAND(I) = -((I+5)/6)*2.0
      DO 402 I=1,NVPROF
 402  VPROF(I) = SIN(((I+2.)*4.)/NS)*3.
      DO 403 I=4,7
 403  BNDOFF(I) = (I-4)*112./57.79
      RETURN
      END
C
      SUBROUTINE TMCOF(A)
C
C     SETS UP COEFFICIENTS FOR CONVERTING GEODETIC TO
C     RECTIFYING LATITUDE AND CONVERSELY
C
      DOUBLE PRECISION A(16),FAC
C
    6 A(10)=(((A(16)*(7.0D0/3.2D1)+(5.0D0/1.6D1))*A(16)+0.5D0)*A(16)
     * +1.0D0)*A(16)*0.25D0
C
      A(1)=-(((A(10)*(1.95D2/6.4D1)+3.25D0)*A(10)+3.75D0)*A(10)+3.0D0)*
     * A(10)
C
      A(2)=(((1.455D3/3.2D1)*A(10)+(7.0D1/3.0D0))*A(10)+7.5D0)*A(10)**2
C
      A(3)=-((7.0D1/3.0D0)+A(10)*(9.45D2/8.0D0))*A(10)**3
C
      A(4)=(3.15D2/4.0D0)*A(10)**4
C
      A(11)=(((7.75D0-(6.57D2/6.4D1)*A(10))*A(10)-5.25D0)*A(10)+3.0D0)*
     * A(10)
C
      A(12)=(((5.045D3/3.2D1)*A(10)-(1.51D2/3.0D0))*A(10)+10.5D0)*
     * A(10)**2
C
      A(13)=((1.51D2/3.0D0)-(3.291D3/8.0D0)*A(10))*A(10)**3
C
      A(14)=(1.097D3/4.0D0)*A(10)**4
C
C        A(1) TO A(4) ARE FOR GEODETIC TO RECTIFYING LATITUDE
C        CONVERSION WHILE A(11) TO A(14) ARE COEFFICIENTS FOR
C        RECTIFYING TO GEODETIC CONVERSION.
C
      FAC=A(10)*A(10)
      A(10)=(((2.25D2/6.4D1)*FAC+2.25D0)*FAC+1.0D0)*(1.0D0-FAC)*
     * (1.0D0-A(10))*A(15)
C
C     A(10) IS NOW SET TO RADIUS OF SPHERE WITH GREAT CIRCLE LENGTH
C     EQUAL TO SPHEROID MERIDIAN LENGTH.
C
      RETURN
      END
C**********************************************************
      SUBROUTINE TMFWD(SLAT,SLON,NORTH,EAST,A,IERR,SK,THET)
C
C CONVERTS LATITUDE AND LONGITUDE IN SECONDS (SLAT AND SLON) TO X AND
C Y ON TRANSVERSE MERCATOR PROJECTION. A(1) TO A(4) ARE COEFFICIENTS
C USED TO CONVERT GEODETIC LATITUDE TO RECTIFYING LATITUDE, A(5) IS
C FALSE EASTING, A(6) IS FALSE NORTHING,A(8) IS SCALE FACTOR AT CENTRAL
C     MERIDIAN.  A(9) IS CENTRAL MERIDIAN IN SECONDS. A(10) IS RADIUS
C    OF SPHERE HAVING A GREAT CIRCLE LENGTH EQUAL TO SPHEROID MERIDIAN
C     LENGTH.  A(11) TO A(14) ARE COEFFICIENTS TO CONVERT RECTIFYING
C     LATITUDE TO GEODETIC LATITUDE.  A(15) IS SEMIMAJOR AXIS OF
C    SPHEROID, AND A(16) IS ECCENTRICITY SQUARED.  IERR IS SET TO 1
C     IF LAT EXCEEDS 84 DEGREES, OR LONG EXCEEDS 0.16 RADIANS
C
      DOUBLE PRECISION SLAT,SLON,A(16),B(12),SINP,COSP,RN,T,TS,ETAS,
     *                 NORTH,EAST,SK,THET
      IERR=0
      IF(DABS(SLAT)-302400.0D0) 8,8,4
    4 IERR=1
      EAST=0.0D0
      NORTH=0.0D0
      GO TO 99
    8 B(10)=(A(9)-SLON) *4.84813681109536D-6
      IF(DABS(B(10))-0.16D0)10,10,4
   10 B(9)=SLAT*4.84813681109536D-6
      SINP=DSIN(B(9))
      COSP=DCOS(B(9))
      RN=A(15)/DSQRT(1.0D0-A(16)*SINP*SINP)
      T=SINP/COSP
      TS=T*T
      B(11)=COSP*COSP
      ETAS=A(16)*B(11)/(1.0D0-A(16))
      B(1)=RN*COSP
      B(3)=(1.0D0-TS+ETAS)*B(1)*B(11)/6.0D0
      B(5)=((TS-18.0D0)*TS+5.0D0+(14.0D0-58.0D0*TS)*ETAS)*B(1)*B(11)*
     * B(11)/120.0D0
      B(7)=(((179.0D0-TS)*TS-479.0D0)*TS+61.0D0)*B(1)*B(11)**3/5040.0D0
      B(12)=B(10)*B(10)
      EAST=(((B(7)*B(12)+B(5))*B(12)+B(3))*B(12)+B(1))*B(10)*A(8)+
     XA(5)
      B(2)=RN*B(11)*T/2.0D0
      B(4)=(ETAS*(9.0D0+4.0D0*ETAS)+5.0D0-TS)*B(2)*B(11)/12.0D0
      B(6)=((TS-58.0D0)*TS+61.0D0+(270.0D0-330.0D0*TS)*ETAS)*B(2)*
     * B(11)*B(11)/360.0D0
      B(8)=(((543.0D0-TS)*TS-3111.0D0)*TS+1385.0D0)*B(2)*B(11)**3/
     * 20160.0D0
      NORTH=(((B(8)*B(12)+B(6))*B(12)+B(4))*B(12)+B(2))*B(12)+
     * ((((A(4)*B(11)+A(3))*B(11)+A(2))*B(11)+A(1))*SINP*COSP+B(9))
     * *A(10)
      NORTH=(NORTH-A(7))*A(8)+A(6)
C
C     COMPUTE SCALE FACTOR  SK
C
C      SK=(((((-24.0D0*ETAS-48.0D0)*ETAS-28.0D0)*ETAS-4.0D0)*TS)+
C     X(((4.0D0*ETAS+13.0D0)*ETAS+14.0D0)*ETAS+5.0D0))*((B(10)**4)/24.0D0
C     X)*B(11)*B(11)+(1.0D0+ETAS)*B(11)*(B(10)*B(10))/2.0D0+1.0D0
C      SK=SK*A(8)
C     COMPUTE CONVERGENCE ANGLE--THET
C
C      THET=(B(10)*SINP*(1.0D0+((B(10)**2)*B(11)/3.0D0)*(1.0D0+3.0D0
C     X*ETAS+2.0D0*ETAS**2)+(B(10)**4)*((B(11)**2)/15.0D0)*(2.0D0-TS)))*
C     X206264.8062470964D0
   99 RETURN
      END
C**********************************************************
      SUBROUTINE TMINV(NORTH,EAST,SLAT,SLON,A,IERR,SK,THET)
C
C COMPUTES LATITUDE AND LONGITUDE IN SECONDS (SLAT AND SLON) FROM GIVEN
C RECTANGULAR COORDINATES X AND Y FOR TRANSVERSE MERCATOR PROJECTION.
C A IS ARRAY OF PARAMETERS USED IN COMPUTATION, DESCRIBED BY COMMENTS
C FOR TMFWD SUBROUTINE. IERR SET TO 1 IF GRID DISTANCE FROM CENTRAL
C MERIDIAN EXCEEDS 0.2 OF SPHEROID SEMIMAJOR AXIS NUMERICALLY OR IF
C ABSOLUTE VALUE OF RECTIFYING LATITUDE EXCEEDS 1.47 RADIANS. SOUTH
C LATITUDES AND EAST LONGITUDE ARE NEGATIVE.
C
      DOUBLE PRECISION SLAT,SLON,A(16),B(12),SINW,COSW,RN,T,TS,ETAS,
     -                 NORTH,EAST,X,Y,SK,THET
C
      Y=NORTH
      X=EAST
      IERR=0
      B(9)=((A(5)-X)*1.0D-6)/A(8)
      IF (DABS(B(9))-1.0D-7*A(15)*2.0D0)8,8,4
    4 IERR=1
      SLAT=0.0
      SLON=0.0
      GO TO 99
    8 B(10)=((Y-A(6))/A(8)+A(7))/A(10)
      IF(DABS(B(10))-1.47D0)10,10,4
   10 SINW=DSIN(B(10))
      COSW=DCOS(B(10))
      B(12)=COSW*COSW
      B(11)=(((A(14)*B(12)+A(13))*B(12)+A(12))*B(12)+A(11))*SINW*COSW
     * +B(10)
      SINW=DSIN(B(11))
      COSW=DCOS(B(11))
      RN=DSQRT(1.0D0-A(16)*SINW*SINW)*1.0D6/A(15)
      T=SINW/COSW
      TS=T*T
      B(12)=COSW*COSW
      ETAS=A(16)*B(12)/(1.0D0-A(16))
      B(1)=RN/COSW
      B(2)=-T*(1.0D0+ETAS)*RN*RN/2.0D0
      B(3)=-(1.0D0+2.0D0*TS+ETAS)*B(1)*RN*RN/6.0D0
      B(4)=(((-6.0D0-ETAS*9.0D0)*ETAS+3.0D0)*TS+(6.0D0-ETAS*3.0D0)*ETAS
     * +5.0D0)*T*RN**4/24.0D0
      B(5)=((TS*24.0D0+ETAS*8.0D0+28.0D0)*TS+ETAS*6.0D0+5.0D0)*B(1)*
     * RN**4/120.0D0
      B(6)=(((ETAS*45.0D0-45.0D0)*TS+ETAS*162.0D0-90.0D0)*TS
     * -ETAS*107.0D0-61.0D0)*T*RN**6/720.0D0
      B(7)=-(((TS*720.0D0+1320.0D0)*TS+662.0D0)*TS+61.0D0)*B(1)*RN**6/
     * 5040.0D0
      B(8)=(((TS*1575.0D0+4095.0D0)*TS+3633.0D0)*TS+1385.0D0)*T*RN**8/
     * 40320.0D0
      B(10)=B(9)*B(9)
      SLAT=((((B(8)*B(10)+B(6))*B(10)+B(4))*B(10)+B(2))*B(10)+B(11))*
     * 206264.8062470964D0
      SLON= (((B(7)*B(10)+B(5))*B(10)+B(3))*B(10)+B(1))*B(9)*
     * 206264.8062470964D0 + A(9)
C      BN=B(9)*RN
C      BNS=BN**2
C      SK=1.0D0+((1.0D0+ETAS)/2.0D0)*BNS+(1.0D0+6.0D0*ETAS+9.0D0
C     X*ETAS*ETAS+4.0D0*ETAS*ETAS*ETAS-24.0D0*ETAS*ETAS*TS-24.0D0
C     X*ETAS*ETAS*ETAS*TS)*BNS*BNS/24.0D0+(BNS*BNS*BNS)/720.0D0
C      SK=SK*A(8)
C     COMPUTE CONVERGENCE ANGLE--THET
C
C      THET=(((((((-24.0D0*ETAS-27.0D0)*ETAS-7.0D0)*ETAS+1.0D0)*ETAS)*TS
C     X)+(5.0D0*TS+3.0D0*TS**2)+((((11.0D0*ETAS+20.0D0)*ETAS+9.0D0)*
C     XETAS+2.0D0)*ETAS)+2.0D0)*(BN**5)*T/15.0D0)+(T*BN)- (((45.0D0*TS
C     X+105.0D0)*TS+77.0D0)*TS+17.0D0)*((BN**7)*T/315.0D0)-(((1.0D0+TS
C     X-ETAS-2.0D0*ETAS**2)*BN**3)*T/3.0D0)
C      THET=-THET*206264.8062470964D0
   99 RETURN
      END
C**********************************************************
      SUBROUTINE TRANSF(DLAT,DLON,TPHI,TLAM,X,Y)
C
C  THIS SUBROUTINE COMPUTES TRANSFORMED PHI AND LAMBDA
C
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON / SER/ A,B,A2,A4,C1,C3,PI
      COMMON / NORM/ Q,T,U,W,E2,P21,SA,CA
      COMMON /PRM/ XJ,S,DEGRAD
      CONV=1.D-7
      DLAT=DLAT/DEGRAD
      DLON=DLON/DEGRAD
C     TEST FOR LATITUDE AND LONGITUDE APPROACHING 90 DEGREES
C
      ifmt = 0    ! bam 7/96
      IF (DLAT.GT.1.570796D0) DLAT=1.570796D0
C
      IF (DLAT.LT.-1.570796D0) DLAT=-1.570796D0
      RADLT=DLAT
      RADLN=DLON
      IF(DLAT.GE.0.0D0) TLAMP=PI/2.0D0
      IF(IFMT.EQ.1) TLAMP=2.5D0*PI
      IF(DLAT.LT.0.0D0) TLAMP=1.5D0*PI
      N=0
  199 SAV=TLAMP
      L=0
      XLAMP=RADLN+P21*TLAMP
      AB1=DCOS(XLAMP)
      IF(DABS(AB1).LT.CONV) XLAMP=XLAMP-1.D-7
      IF(AB1.GE.0.D0) SCL=1.D0
      IF(AB1.LT.0.D0) SCL=-1.D0
      AB2=TLAMP-(SCL)*DSIN(TLAMP)*PI/2.D0
  200 XLAMT=RADLN+P21*SAV
      C=DCOS(XLAMT)
      IF (DABS(C).LT.1.D-7) XLAMT=XLAMT-1.D-7
      XLAM=(((1.D0-E2)*DTAN(RADLT)*SA)+DSIN(XLAMT)*CA)/C
      TLAM=DATAN(XLAM)
      TLAM=TLAM+AB2
      ABS=DABS(SAV)-DABS(TLAM)
      IF(DABS(ABS).LT.CONV) GO TO 60
      SAV=TLAM
      L=L+1
      IF (L .GT. 50) GO TO 100
      GO TO 200
C
C     ADJUST FOR LANDSAT PATH ORIGIN
C
   60 RLM=PI*(16.D0/31.D0+1.D0/248.D0)
      RLM2=RLM+2.0D0*PI
      N=N+1
      IF(N.GE.3) GO TO 300
      IF(TLAM.GT.RLM.AND.TLAM.LT.RLM2) GO TO 300
      IF(TLAM.LE.RLM)TLAMP=2.5D0*PI
      IF(TLAM.GE.RLM2) TLAMP=PI/2.0D0
      GO TO 199
  100 WRITE(6,50) SAV,TLAM,DLAT,DLON
   50 FORMAT(1X,'  50 ITERATIONS WITHOUT CONV; SAV/TLAM ',5X,2F15.10/
     *2F25.10)
  300 CONTINUE
C
C     TLAM COMPUTED - NOW COMPUTE TPHI
C
      DS=DSIN(TLAM)
      DD=DS*DS
      DP=DSIN(RADLT)
      TPHI=DASIN(((1.D0-E2)*CA*DP-SA*DCOS(RADLT)*DSIN(XLAMT))/DSQRT(1.D
     *0-E2*DP*DP))
C
C     COMPUTE X AND Y
C
      XTAN = (PI/4.0D0) + (TPHI/2.0D0)
      TANLG = DLOG(DTAN(XTAN))
      SD=DSIN(TLAM)
      SDSQ=SD*SD
      S=P21*SA*DCOS(TLAM)*DSQRT((1.D0+T*SDSQ)/((1.D0+W*SDSQ)*(1.D0+Q*SDS
     *Q)))
      D=DSQRT(XJ*XJ+S*S)
      X=B*TLAM+A2*DSIN(2.D0*TLAM)+A4*DSIN(4.D0*TLAM)-TANLG*S/D
      X=A*X
      Y=C1*SD+C3*DSIN(3.D0*TLAM)+TANLG*XJ/D
      Y=A*Y
      RETURN
      END
$ VOKAGLEVE
$ Return
$!#############################################################################
$PDF_File:
$ create polymap.pdf
PROCESS    HELP=*
PARM INP TYPE=(STRING,72)
PARM OUT TYPE=(STRING,72)
PARM PROJ TYPE=KEYWORD VALID=(LAMBERT,ALBERS,ALBERS2,UTM,+
LANDSAT,SOM)
PARM NOPRINT  TYPE=KEYWORD COUNT=(0:1) VALID=(NOPRINT) DEFAULT=--
PARM MODE     TYPE=KEYWORD COUNT=(0:1) VALID=(INVERSE) DEFAULT=--
PARM SKIP     TYPE=INTEGER DEFAULT=0
PARM IGNORE   TYPE=REAL  COUNT=2  DEFAULT=(0,0)
PARM ZONE     TYPE=INTEGER DEFAULT=0
PARM INSI     TYPE=REAL COUNT=(0:2) DEFAULT=0
PARM SENS     TYPE=INTEGER DEFAULT=0
PARM LATI     TYPE=REAL DEFAULT=0
PARM BAND     TYPE=INTEGER DEFAULT=0
PARM INCON    TYPE=REAL COUNT=(0:6) DEFAULT=0.
PARM OUTCON   TYPE=REAL COUNT=(0:6) DEFAULT=0.
PARM CMER     TYPE=REAL DEFAULT=180.
PARM STPAR    TYPE=REAL COUNT=(0:2) DEFAULT=(33.,45.)
PARM SPHEROID TYPE=INTEGER DEFAULT=1
PARM PATH     TYPE=INTEGER DEFAULT=1
END-PROC
.TITLE
VICAR/IBIS Program POLYMAP
.HELP     
PURPOSE

     POLYMAP  is used to convert point or polygon files from 
     one  map  projection  to  another.    The  file  to  be 
     converted  must  be  in the  standard  VICAR  polygonal 
     format (sequence of points X1,Y1,X2,Y2,...  in fullword 
     floating).   Several map projections are supported (see
     parameters).

.PAGE
TAE COMMAND LINE FORMAT

     POLYMAP INP=A OUT=B PARAMS

     where

     INP                 is  an input point on polygon  file 
                         in  the  standard  VICAR  polygonal 
                         format.
     
     OUT                 is the output file in the  standard 
                         IBIS format.

     PARAMS              is a standard VICAR parameter field.
.PAGE
OPERATION

     POLYMAP  performs  the map transformation indicated  by 
     the  keyword  to transform an input x,y  pair  into  an 
     output  x,y  pair.    It  is  expected  that  more  map 
     transformations will be added when needed.

.PAGE
WRITTEN BY:              A. L. Zobrist
COGNIZANT PROGRAMMER:    K. F. Evans
REVISION:                3                12OCT81

REVISION SUMMARY
REVISION                 2                12OCT81 
     Addition of new parameter keywords ALBE, LANDSAT, ALB2, 
     INCON, OUTCON.

REVISION                 3                13JUL84
     Addition of spheroid models, parameter SPHEROID.
     Addition   of   Space  Oblique   Mercator   Projection, 
     PROJECTION=SOM.
.PAGE
.LEVEL1
.VARIABLE INP
Input polygon file
.VARIABLE OUT
Output polygon file
.VARIABLE PROJ
Specifies map projection
UTM, LAMBERT, ALBERS, ALBERS2,
LANDSAT, SOM.
.VARIABLE NOPRINT
Suppresses printing of 
messages
.VARIABLE LATI
Frame latitude for LANDSAT
.VARIABLE SENS
Sensor number for LANDSAT
.VARIABLE BAND
Band number for LANDSAT
.VARIABLE STPAR
Standard parallel (LAMBERT,
  ALBERS, ALBERS2)
.VARIABLE CMER
Central meridian for LAMBERT
.VARIABLE INCON
Specifies transform before conv
.VARIABLE OUTCON
Specifies transform after conv
.VARIABLE SKIP
Used to skip nominal data
.VARIABLE IGNORE
Pair (x,y) to ignore
.VARIABLE ZONE
UTM zone - negative 
for Southern hemisphere
.VARIABLE INSI
INSI(1) = Line dimension of raw LANDSAT
INSI(2) = Sample dimension of raw LANDSAT
.VARIABLE PATH
Satellite path for SOM
.VARIABLE SPHEROID
Spheroid model for UTM
.VARIABLE MODE
INVERSE - inverse transform
.LEVEL2
.VARIABLE INP
    INP=A                Input polygon file
.VARIABLE OUT
    OUT=B                Output polygon file
.VARIABLE PROJ
          PROJ=UTM       specifies  that  the conversion  is 
                         from  lat-long to UTM.   The  first 
                         point  to be  converted  determines 
                         the UTM zone, which is printed out, 
                         and  then all points are referenced 
                         to that UTM zone even if they would 
                         ordinarily  fall in  another  zone.  
                         This  is  done to provide a  single 
                         map projection for the entire  data 
                         set.

          PROJ=LAMBERT   specifies  that the  conversion  is 
                         from lat-long to Lambert  Conformal 
                         Conic  with two standard  parallels          
                         L,U   stated  in  degrees  with   a 
                         decimal point.   The default L,U is 
                         33.,45.

          PROJ=ALBERS    specifies  that  the conversion  is 
                         from  lat-long to Albers Equal Area 
                         Projection   with   two    standard          
                         parallels  L,U  stated  in  degrees 
                         with  a decimal point.  The default 
                         L,U is 33.,45.

          PROJ=ALBERS2   specifies  that the  conversion  is 
                         from lat-long to a special formula-
                         tion  of  the  Albers  Equal  Area
                         Projection which includes eccentri-
                         city of the spheroid.  The standard 
                         parallels  L,U have default  values 
                         of 33.,45.
     
          PROJ=LANDSAT   specifies    that   the   geometric 
                         transformation  contained  in   the 
                         routine  ERTMGEOM is to be  applied 
                         so that points in the raw image can 
                         be  moved to their location in  the 
                         logged   image. The next five key-
                         words must be specified.    
          PROJ=SOM       Specifies  Space  Oblique  Mercator
                         projection.
.VARIABLE NOPRINT
			 Suppresses printing of printout messages.

.VARIABLE INSI
     INSI(1)=L           These  keywords specify the parame-
     INSI(2)=S           ters  used in logging  the  Landsat 
     LATI=RLAT           image  with  ERTMGEOM so  the  same 
     SENS=N              transformation  can  be applied  to 
     BAND=K              the point data set. L and S are the 
                         dimensions  of  the  raw   Landsat.  
                         RLAT is the latitude of the Landsat 
                         frame.    N  specifies  the  sensor 
                         platform.   Currently  N=1,2,3  for 
                         Landsat   1,2,3  respectively.    K 
                         specifies  which band was  used  to 
                         locate  the  point set in  the  raw 
                         frame (currently 4 through 7).  K=0 
                         can  be used if no band offsets are 
                         used.
.VARIABLE LATI
     INSI(1)=L           These  keywords specify the parame
     INSI(2)=S           ters  used in logging  the  Landsat 
     LATI=RLAT           image  with  ERTMGEOM so  the  same 
     SENS=N              transformation  can  be applied  to 
     BAND=K              the point data set. L and S are the 
                         dimensions  of  the  raw   Landsat.  
                         RLAT is the latitude of the Landsat 
                         frame.    N  specifies  the  sensor 
                         platform.   Currently  N=1,2,3  for 
                         Landsat   1,2,3  respectively.    K 
                         specifies  which band was  used  to 
                         locate  the  point set in  the  raw 
                         frame (currently 4 through 7).  K=0 
                         can  be used if no band offsets are 
                         used.
.VARIABLE SENS
     INSI(1)=L           These  keywords specify the parame
     INSI(2)=S           ters  used in logging  the  Landsat 
     LATI=RLAT           image  with  ERTMGEOM so  the  same 
     SENS=N              transformation  can  be applied  to 
     BAND=K              the point data set. L and S are the 
                         dimensions  of  the  raw   Landsat.  
                         RLAT is the latitude of the Landsat 
                         frame.    N  specifies  the  sensor 
                         platform.   Currently  N=1,2,3  for 
                         Landsat   1,2,3  respectively.    K 
                         specifies  which band was  used  to 
                         locate  the  point set in  the  raw 
                         frame (currently 4 through 7).  K=0 
                         can  be used if no band offsets are 
                         used.
.VARIABLE BAND
     INSI(1)=L           These  keywords specify the parame
     INSI(2)=S           ters  used in logging  the  Landsat 
     LATI=RLAT           image  with  ERTMGEOM so  the  same 
     SENS=N              transformation  can  be applied  to 
     BAND=K              the point data set. L and S are the 
                         dimensions  of  the  raw   Landsat.  
                         RLAT is the latitude of the Landsat 
                         frame.    N  specifies  the  sensor 
                         platform.   Currently  N=1,2,3  for 
                         Landsat   1,2,3  respectively.    K 
                         specifies  which band was  used  to 
                         locate  the  point set in  the  raw 
                         frame (currently 4 through 7).  K=0 
                         can  be used if no band offsets are 
                         used.
.VARIABLE STPAR
     STPAR=(L,U)         Standard parallels in degrees, used 
                         for  LAMBERT,  ALBERS  and  ALBERS2 
                         projections. L-lower, U-upper.
                         Default: L=33., U=45.

.VARIABLE CMER
     CMER=M              Central meridian, used  in  LAMBERT
                         projection.
.VARIABLE INCON
     INCON=(C1,...,C6)    This  specifies an input conversion 
                         prior  to  application of  the  map 
                         transformation:               

                         X' = C1.X +C2.Y + C3

                         Y' = C4.X + C5.Y + C6

.VARIABLE OUTCON
     OUTCON=(D1,...,D6)   This specifies an output conversion 
                         after  map  projection in the  same 
                         manner as INCON.
.VARIABLE SKIP
     SKIP=n              This is used for skipping nominal 
     			 data.  Two data words are read and
			 then n words are skipped, etc.
			 The skipped data are carried along
			 unchanged to the output file.

.VARIABLE IGNORE
     IGNORE=(x,y)        causes  all points with  the  value 
                         (x,y)   to   be  ignored   by   the 
                         transformation.   The default is to 
                         ignore  (0.,0.).   x and y must  be 
                         given in floating format.
.VARIABLE ZONE
     ZONE=z              The   integer  z  forces  a   zonal 
                         mapping  (such  as UTM) to be in  a 
                         specific zone.  The negative of the
			 zone number is used to indicate that
			 the UTM coordinates are in the 
			 Southern hemisphere.
.VARIABLE MODE
      'INVERSE		 Does inverse transformation

.VARIABLE PATH           Specifies satellite path for SOM
     PATH=p              projection

.VARIABLE SPHEROID       Specifies spheroid model for UTM
     SPHEROID=s          projection.
                             1  = CLARK 1866 (Default)
                             2  = CLARK 1880
                             3  = BESSEL
                             4  = MODIFIED MERCURY 1968
                             5  = INTERNATIONAL
                             6  = WORLD GEOD. SYS. 1972
                             7  = NEW INTERNATIONAL 1967
                             8  = EVEREST
                             9  = WORLD GEOD. SYS. 1966
                             10 = GEOD. REF. SYS. 1980
.EN
$ Return
$!#############################################################################
$Imake_File:
$ create polymap.imake
#define PROGRAM polymap

#define MODULE_LIST polymap.f

#define MAIN_LANG_FORTRAN
#define R2LIB

#define USES_FORTRAN

#define LIB_P2SUB
#define LIB_RTL
#define LIB_TAE
$ Return
$!#############################################################################
$Test_File:
$ create tstpolymap.pdf
procedure
refgbl $echo
refgbl $autousage
refgbl $syschar
body
local PATH string init="WMS_TEST_WORK:[TESTDATA.MISC]"
let $autousage="none"
let _onfail="continue"
let $echo="no"
if ($syschar(1) = "UNIX")
  let PATH="/project/test_work/testdata/misc/"
end-if
write "THIS IS A TEST OF MODULE polymap"
polymap &"PATH"b.test c.test sphe=1 skip=2 zone=11 'utm
polymap &"PATH"b.test c.test insi=(100,100) sens=1 lati=1 band=0 'landsat
polymap &"PATH"b.test c.test insi=(100,100) sens=1 lati=1 band=0 'som
end-proc
$ Return
$!#############################################################################
